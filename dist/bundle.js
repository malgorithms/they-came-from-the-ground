/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/ai/ai-base.ts":
/*!***************************!*\
  !*** ./src/ai/ai-base.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AiBase\": () => (/* binding */ AiBase)\n/* harmony export */ });\n/* harmony import */ var _future_prediction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../future-prediction */ \"./src/future-prediction.ts\");\n/* harmony import */ var _tweakables__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tweakables */ \"./src/tweakables.ts\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../types */ \"./src/types.ts\");\n\n\n\nclass AiBase {\n    constructor() {\n        this.lastMoveLeft = 0;\n        this.lastMoveRight = 0;\n    }\n    getNextBallEnteringMyJumpRange(o, myPlayerSide) {\n        let result = (0,_future_prediction__WEBPACK_IMPORTED_MODULE_0__.unknownState)();\n        for (const pred of o.ballPredictions) {\n            const lookup = pred.ballEnteringJumpRange(myPlayerSide);\n            if (!lookup)\n                throw new Error('failed to lookup');\n            if (!(result === null || result === void 0 ? void 0 : result.isKnown) || lookup.time < result.time) {\n                result = lookup;\n            }\n        }\n        return result;\n    }\n    getNextBallHittingOnMySide(o, myPlayerSide) {\n        const net = o.gameConfig.net;\n        const result = (0,_future_prediction__WEBPACK_IMPORTED_MODULE_0__.unknownState)();\n        const amLeft = myPlayerSide === _types__WEBPACK_IMPORTED_MODULE_2__.PlayerSide.Left;\n        for (const p of o.ballPredictions) {\n            const hittingGround = p.ballHittingGround;\n            if ((amLeft && hittingGround.pos.x > net.center.x) || (!amLeft && hittingGround.pos.x < net.center.x)) {\n                continue;\n            }\n            if (hittingGround.isKnown && hittingGround.time < result.time) {\n                result.isKnown = true;\n                result.time = hittingGround.time;\n                result.pos = hittingGround.pos;\n            }\n        }\n        return result;\n    }\n    static goToSize(dt, me, fractionOfWayFromSmallToLarge) {\n        const minD = _tweakables__WEBPACK_IMPORTED_MODULE_1__[\"default\"].player.minDiameter;\n        const maxD = _tweakables__WEBPACK_IMPORTED_MODULE_1__[\"default\"].player.maxDiameter;\n        const targetSize = minD + fractionOfWayFromSmallToLarge * (maxD - minD);\n        if (me.physics.diameter < targetSize)\n            me.grow(dt, _tweakables__WEBPACK_IMPORTED_MODULE_1__[\"default\"].player.growSpeed);\n        else if (me.physics.diameter > targetSize)\n            me.grow(dt, -_tweakables__WEBPACK_IMPORTED_MODULE_1__[\"default\"].player.growSpeed);\n    }\n    moveLeft(gameTime, me) {\n        this.lastMoveLeft = gameTime.totalGameTime.totalMilliseconds;\n        me.moveLeft();\n    }\n    moveRight(gameTime, me) {\n        this.lastMoveRight = gameTime.totalGameTime.totalMilliseconds;\n        me.moveRight();\n    }\n    moveRationally(gameTime, me, fractionOfMaxVelocity) {\n        if (fractionOfMaxVelocity < 0)\n            this.lastMoveLeft = gameTime.totalGameTime.totalMilliseconds;\n        else if (fractionOfMaxVelocity > 0)\n            this.lastMoveRight = gameTime.totalGameTime.totalMilliseconds;\n        me.moveRationally(fractionOfMaxVelocity);\n    }\n    static jumpIfOkay(me) {\n        if (me.isOnHeight(0.0)) {\n            me.jump();\n        }\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/ai/ai-base.ts?");

/***/ }),

/***/ "./src/ai/black-ai.ts":
/*!****************************!*\
  !*** ./src/ai/black-ai.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BlackAi\": () => (/* binding */ BlackAi)\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types */ \"./src/types.ts\");\n/* harmony import */ var _ai_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ai-base */ \"./src/ai/ai-base.ts\");\n/* harmony import */ var _white_ai__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./white-ai */ \"./src/ai/white-ai.ts\");\n\n\n\n//\n// TODO: replace that this is just using a green AI.\n//\nclass BlackAi extends _ai_base__WEBPACK_IMPORTED_MODULE_1__.AiBase {\n    constructor() {\n        super();\n        this.hiddenWhiteBrain = new _white_ai__WEBPACK_IMPORTED_MODULE_2__.WhiteAi();\n    }\n    think(o) {\n        if ((o.p0Score + o.p1Score) % 3 == 0 && Math.sin(o.accumulatedPointTime / 3) < 0) {\n            this.hiddenWhiteBrain.think(o);\n            return;\n        }\n        const me = o.me;\n        const dt = o.gameTime.elapsedGameTime.totalSeconds;\n        // Just jump sometimes\n        if (o.accumulatedPointTime < 1) {\n            BlackAi.jumpIfOkay(me);\n        }\n        BlackAi.goToSize(dt, me, 0.9);\n        if (o.accumulatedPointTime < 1.0)\n            return;\n        let stateToWatch = o.ballPredictions[0].ballEnteringJumpRange(o.myPlayerSide);\n        const amLeft = o.myPlayerSide === _types__WEBPACK_IMPORTED_MODULE_0__.PlayerSide.Left;\n        if (!stateToWatch.isKnown)\n            stateToWatch = o.ballPredictions[0].ballHittingGround;\n        if (stateToWatch.isKnown)\n            stateToWatch.pos.x += ((amLeft ? -1.0 : 1.0) * me.physics.diameter) / 6.0;\n        // What to do if we have no idea\n        if (!stateToWatch.isKnown) {\n            if (me.physics.center.x < o.gameConfig.net.center.x + o.gameConfig.net.width / 2 + (2 * me.physics.diameter) / 3)\n                this.moveRight(o.gameTime, me);\n            else if (me.physics.center.x > 1.0 - (2 * me.physics.diameter) / 3)\n                this.moveLeft(o.gameTime, me);\n            else\n                this.moveRationally(o.gameTime, me, 0.0);\n            return;\n        }\n        // Let's add some randomness for stupidity\n        stateToWatch.pos.x += (o.gameConfig.balls[0].physics.diameter * Math.sin(o.gameTime.elapsedGameTime.totalSeconds)) / 6;\n        stateToWatch.pos.y += (o.gameConfig.balls[0].physics.diameter * Math.sin(o.gameTime.elapsedGameTime.totalSeconds)) / 6;\n        // At this point we know we have a state to watch\n        if (!amLeft && me.physics.center.x < o.gameConfig.net.center.x - o.gameConfig.net.width / 2) {\n            // keep me on my side of net\n            BlackAi.jumpIfOkay(me);\n            this.moveRight(o.gameTime, me);\n        }\n        else if (me.physics.center.x > stateToWatch.pos.x + me.physics.diameter / 10.0 &&\n            o.gameTime.totalGameTime.totalMilliseconds - this.lastMoveRight > 5)\n            this.moveLeft(o.gameTime, me);\n        else if (me.physics.center.x < stateToWatch.pos.x - me.physics.diameter / 10.0 &&\n            o.gameTime.totalGameTime.totalMilliseconds - this.lastMoveLeft > 5)\n            this.moveRight(o.gameTime, me);\n        else\n            this.moveRationally(o.gameTime, me, 0.0);\n        const timeTillJump = me.getTimeToJumpToHeight(o.gameGravity.y, stateToWatch.pos.y);\n        // Only jump sometimes\n        if (stateToWatch.time < timeTillJump && o.gameTime.totalGameTime.totalSeconds % 50 != 0)\n            BlackAi.jumpIfOkay(me);\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/ai/black-ai.ts?");

/***/ }),

/***/ "./src/ai/green-ai.ts":
/*!****************************!*\
  !*** ./src/ai/green-ai.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GreenAi\": () => (/* binding */ GreenAi)\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types */ \"./src/types.ts\");\n/* harmony import */ var _ai_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ai-base */ \"./src/ai/ai-base.ts\");\n\n\nclass GreenAi extends _ai_base__WEBPACK_IMPORTED_MODULE_1__.AiBase {\n    constructor() {\n        super();\n        this.reactionTime = 0.4;\n    }\n    think(o) {\n        const me = o.me;\n        const dt = o.gameTime.elapsedGameTime.totalMilliseconds / 1000;\n        // Just jump sometimes\n        if (o.accumulatedPointTime < 1) {\n            GreenAi.jumpIfOkay(me);\n        }\n        GreenAi.goToSize(dt, me, 0.9);\n        if (o.accumulatedPointTime < 1.0)\n            return;\n        let stateToWatch = this.getNextBallEnteringMyJumpRange(o, o.myPlayerSide);\n        const amLeft = o.myPlayerSide === _types__WEBPACK_IMPORTED_MODULE_0__.PlayerSide.Left;\n        if (!stateToWatch.isKnown)\n            stateToWatch = this.getNextBallHittingOnMySide(o, o.myPlayerSide);\n        if (stateToWatch.isKnown)\n            stateToWatch.pos.x += ((amLeft ? -1.0 : 1.0) * me.physics.diameter) / 6.0;\n        // What to do if we have no idea\n        if (!(stateToWatch === null || stateToWatch === void 0 ? void 0 : stateToWatch.isKnown)) {\n            if (me.physics.center.x < o.gameConfig.net.center.x + o.gameConfig.net.width / 2 + (2 * me.physics.diameter) / 3)\n                this.moveRight(o.gameTime, me);\n            else if (me.physics.center.x > 1.0 - (2 * me.physics.diameter) / 3)\n                this.moveLeft(o.gameTime, me);\n            else\n                this.moveRationally(o.gameTime, me, 0.0);\n            return;\n        }\n        if (stateToWatch.time < this.reactionTime) {\n            // Let's add some randomness for stupidity\n            stateToWatch.pos.x += (o.gameConfig.balls[0].physics.diameter * Math.sin(o.gameTime.totalGameTime.totalSeconds)) / 1.5;\n            stateToWatch.pos.y += (o.gameConfig.balls[0].physics.diameter * Math.sin(o.gameTime.totalGameTime.totalSeconds)) / 1.5;\n            // At this point we know we have a state to watch\n            // keep me on my side of net\n            if (!amLeft && me.physics.center.x < o.gameConfig.net.center.x - o.gameConfig.net.width / 2) {\n                GreenAi.jumpIfOkay(me);\n                this.moveRight(o.gameTime, me);\n            }\n            else if (me.physics.center.x > stateToWatch.pos.x + me.physics.diameter / 10.0 &&\n                o.gameTime.totalGameTime.totalMilliseconds - this.lastMoveRight > 300.0) {\n                this.moveLeft(o.gameTime, me);\n            }\n            else if (me.physics.center.x < stateToWatch.pos.x - me.physics.diameter / 10.0 &&\n                o.gameTime.totalGameTime.totalMilliseconds - this.lastMoveLeft > 300.0) {\n                this.moveRight(o.gameTime, me);\n            }\n            else {\n                this.moveRationally(o.gameTime, me, 0.0);\n            }\n            let timeTillJump = me.getTimeToJumpToHeight(o.gameGravity.y, stateToWatch.pos.y);\n            // Add a random amount from it to jump an unpredictable late (or early) amount.\n            timeTillJump += 0.3 * Math.sin(o.accumulatedPointTime);\n            // Only jump sometimes\n            const seconds = Math.floor(o.gameTime.totalGameTime.totalSeconds);\n            if (stateToWatch.time < timeTillJump && seconds % 2 != 0)\n                GreenAi.jumpIfOkay(me);\n        }\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/ai/green-ai.ts?");

/***/ }),

/***/ "./src/ai/purple-ai.ts":
/*!*****************************!*\
  !*** ./src/ai/purple-ai.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PurpleAi\": () => (/* binding */ PurpleAi)\n/* harmony export */ });\n/* harmony import */ var _future_prediction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../future-prediction */ \"./src/future-prediction.ts\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types */ \"./src/types.ts\");\n/* harmony import */ var _ai_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ai-base */ \"./src/ai/ai-base.ts\");\n\n\n\n//\n// TODO: replace that this is just using a green AI.\n//\nclass PurpleAi extends _ai_base__WEBPACK_IMPORTED_MODULE_2__.AiBase {\n    constructor() {\n        super();\n    }\n    think(o) {\n        const me = o.me;\n        const dt = o.gameTime.elapsedGameTime.totalSeconds;\n        if (o.accumulatedPointTime < 1.0)\n            return;\n        PurpleAi.goToSize(dt, me, 0.0);\n        if (o.gameConfig.balls[0].physics.vel.x == 0 && o.gameConfig.balls[0].physics.center.x == 0.25) {\n            // could have it do some kind of taunting here\n            return;\n        }\n        let stateToWatch = (0,_future_prediction__WEBPACK_IMPORTED_MODULE_0__.unknownState)();\n        const enteringMyRange = this.getNextBallEnteringMyJumpRange(o, o.myPlayerSide);\n        const amLeft = o.myPlayerSide === _types__WEBPACK_IMPORTED_MODULE_1__.PlayerSide.Left;\n        const landingOnMySide = this.getNextBallHittingOnMySide(o, o.myPlayerSide);\n        const timeToLanding = Math.abs(landingOnMySide.pos.x - me.physics.center.x) / me.maxVel.x;\n        if (landingOnMySide.isKnown && (!enteringMyRange.isKnown || landingOnMySide.time < timeToLanding + 0.1)) {\n            stateToWatch = landingOnMySide;\n            stateToWatch.pos.x += ((amLeft ? -1.0 : 1.0) * me.physics.diameter) / 6.0;\n        }\n        else if (enteringMyRange.isKnown) {\n            stateToWatch = stateToWatch = enteringMyRange;\n            stateToWatch.pos.x += ((amLeft ? -1.0 : 1.0) * me.physics.diameter) / 6.0;\n        }\n        // What to do if we have no idea\n        if (!(stateToWatch === null || stateToWatch === void 0 ? void 0 : stateToWatch.isKnown)) {\n            // Half the time go to the top of the net. The other half, do other crap.\n            if ((o.accumulatedPointTime / 10) % 2 == 1) {\n                if (me.physics.center.x > o.gameConfig.net.center.x + o.gameConfig.net.width / 2) {\n                    PurpleAi.jumpIfOkay(me);\n                    this.moveLeft(o.gameTime, me);\n                }\n                else if (me.physics.center.x < o.gameConfig.net.center.x - o.gameConfig.net.width / 2) {\n                    PurpleAi.jumpIfOkay(me);\n                    this.moveRight(o.gameTime, me);\n                }\n                else {\n                    this.moveRationally(o.gameTime, me, (o.gameConfig.net.center.x - me.physics.center.x) / (o.gameConfig.net.width / 2));\n                }\n            }\n            else {\n                if (me.physics.center.x < o.gameConfig.net.center.x + o.gameConfig.net.width / 2 + (2 * me.physics.diameter) / 3)\n                    this.moveRight(o.gameTime, me);\n                else if (me.physics.center.x > 1.0 - (2 * me.physics.diameter) / 3)\n                    this.moveLeft(o.gameTime, me);\n                else\n                    this.moveRationally(o.gameTime, me, 0.0);\n            }\n            return;\n        }\n        // At this point we know we have a state to watch\n        if (!amLeft && me.physics.center.x < o.gameConfig.net.center.x - o.gameConfig.net.width / 2) {\n            // keep me on my side of net\n            PurpleAi.jumpIfOkay(me);\n            this.moveRight(o.gameTime, me);\n        }\n        else if (me.physics.center.x > stateToWatch.pos.x + me.physics.diameter / 10.0 &&\n            o.gameTime.totalGameTime.totalMilliseconds - this.lastMoveRight > 5)\n            this.moveLeft(o.gameTime, me);\n        else if (me.physics.center.x < stateToWatch.pos.x - me.physics.diameter / 10.0 &&\n            o.gameTime.totalGameTime.totalMilliseconds - this.lastMoveLeft > 5)\n            this.moveRight(o.gameTime, me);\n        else\n            this.moveRationally(o.gameTime, me, 0.0);\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/ai/purple-ai.ts?");

/***/ }),

/***/ "./src/ai/white-ai.ts":
/*!****************************!*\
  !*** ./src/ai/white-ai.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WhiteAi\": () => (/* binding */ WhiteAi)\n/* harmony export */ });\n/* harmony import */ var _future_prediction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../future-prediction */ \"./src/future-prediction.ts\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types */ \"./src/types.ts\");\n/* harmony import */ var _ai_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ai-base */ \"./src/ai/ai-base.ts\");\n\n\n\nclass WhiteAi extends _ai_base__WEBPACK_IMPORTED_MODULE_2__.AiBase {\n    constructor() {\n        super();\n        // not jumping right at the start of a point prevents WhiteAi from\n        // getting aced with an underbelly serve\n        this.noJumpingBefore = 1.5;\n    }\n    jmp(o) {\n        if (o.accumulatedPointTime > this.noJumpingBefore)\n            WhiteAi.jumpIfOkay(o.me);\n    }\n    think(o) {\n        const me = o.me;\n        const opponent = o.opponent;\n        if (!opponent)\n            throw new Error('bs');\n        const dt = o.gameTime.elapsedGameTime.totalSeconds;\n        WhiteAi.goToSize(dt, me, 0.7);\n        if (o.accumulatedPointTime < 1.0)\n            return;\n        else {\n            WhiteAi.goToSize(dt, me, 0.0);\n        }\n        // PERFORM A MIRROR MANEUVER\n        if (o.accumulatedPointTime < 0.5) {\n            let offset = (me.physics.center.x - o.gameConfig.net.center.x - (o.gameConfig.net.center.x - opponent.physics.center.x)) / me.physics.diameter;\n            if (offset > 1.0)\n                offset = 1.0;\n            if (offset < -1.0)\n                offset = 1.0;\n            this.moveRationally(o.gameTime, me, -offset);\n            if (opponent.physics.center.y > me.physics.center.y) {\n                this.jmp(o);\n            }\n            return;\n        }\n        if (o.gameConfig.balls[0].physics.vel.x == 0 && o.gameConfig.balls[0].physics.center.x == 0.25) {\n            // Don't move if opponent hasn't.\n            return;\n        }\n        let stateToWatch = (0,_future_prediction__WEBPACK_IMPORTED_MODULE_0__.unknownState)();\n        const amLeft = o.myPlayerSide === _types__WEBPACK_IMPORTED_MODULE_1__.PlayerSide.Left;\n        const enteringMyRange = this.getNextBallEnteringMyJumpRange(o, o.myPlayerSide);\n        const landingOnMySide = this.getNextBallHittingOnMySide(o, o.myPlayerSide);\n        const timeToLanding = Math.abs(landingOnMySide.pos.x - me.physics.center.x) / me.maxVel.x;\n        if (landingOnMySide.isKnown && (!enteringMyRange.isKnown || landingOnMySide.time < timeToLanding + 0.1)) {\n            stateToWatch = landingOnMySide;\n            stateToWatch.pos.x += ((amLeft ? -1.0 : 1.0) * me.physics.diameter) / 6.0;\n        }\n        else if (enteringMyRange.isKnown) {\n            stateToWatch = stateToWatch = enteringMyRange;\n            stateToWatch.pos.x += ((amLeft ? -1.0 : 1.0) * me.physics.diameter) / 6.0;\n        }\n        // What to do if we have no idea\n        if (!(stateToWatch === null || stateToWatch === void 0 ? void 0 : stateToWatch.isKnown)) {\n            // Half the time go to the top of the net. The other half, do other crap.\n            if ((Math.floor(o.accumulatedPointTime) / 10) % 2 == 1) {\n                if (me.physics.center.x > o.gameConfig.net.center.x + o.gameConfig.net.width / 2) {\n                    this.jmp(o);\n                    this.moveLeft(o.gameTime, me);\n                }\n                else if (me.physics.center.x < o.gameConfig.net.center.x - o.gameConfig.net.width / 2) {\n                    this.jmp(o);\n                    this.moveRight(o.gameTime, me);\n                }\n                else {\n                    this.moveRationally(o.gameTime, me, (o.gameConfig.net.center.x - me.physics.center.x) / (o.gameConfig.net.width / 2));\n                }\n            }\n            else {\n                if (me.physics.center.x < o.gameConfig.net.center.x + o.gameConfig.net.width / 2 + (2 * me.physics.diameter) / 3)\n                    this.moveRight(o.gameTime, me);\n                else if (me.physics.center.x > 1.0 - (2 * me.physics.diameter) / 3)\n                    this.moveLeft(o.gameTime, me);\n                else\n                    this.moveRationally(o.gameTime, me, 0.0);\n            }\n            return;\n        }\n        // At this point we know we have a state to watch\n        if (!amLeft && me.physics.center.x < o.gameConfig.net.center.x - o.gameConfig.net.width / 2) {\n            // keep me on my side of net\n            this.jmp(o);\n            this.moveRight(o.gameTime, me);\n        }\n        else if (me.physics.center.x > stateToWatch.pos.x + me.physics.diameter / 10.0 &&\n            o.gameTime.totalGameTime.totalMilliseconds - this.lastMoveRight > 5)\n            this.moveLeft(o.gameTime, me);\n        else if (me.physics.center.x < stateToWatch.pos.x - me.physics.diameter / 10.0 &&\n            o.gameTime.totalGameTime.totalMilliseconds - this.lastMoveLeft > 5)\n            this.moveRight(o.gameTime, me);\n        else\n            this.moveRationally(o.gameTime, me, 0.0);\n        const timeTillJump = me.getTimeToJumpToHeight(o.gameGravity.y, stateToWatch.pos.y);\n        // When is it safe to jump?\n        //1. when there's no known landing\n        if (stateToWatch.time < timeTillJump && !landingOnMySide.isKnown) {\n            this.jmp(o);\n        }\n        //2. when there's 1 known landing\n        let count = 0;\n        for (const f of o.ballPredictions) {\n            if (f.ballHittingGround.isKnown) {\n                count++;\n            }\n        }\n        if (count <= 1 && stateToWatch.time < timeTillJump) {\n            this.jmp(o);\n        }\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/ai/white-ai.ts?");

/***/ }),

/***/ "./src/atmosphere.ts":
/*!***************************!*\
  !*** ./src/atmosphere.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Atmosphere\": () => (/* binding */ Atmosphere)\n/* harmony export */ });\n/* harmony import */ var _cloud__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cloud */ \"./src/cloud.ts\");\n/* harmony import */ var _tweakables__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tweakables */ \"./src/tweakables.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\n\n\n\nclass Atmosphere {\n    constructor(canvasManager) {\n        this.numClouds = _tweakables__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cloud.num;\n        this.sunnyness = 1; // 1.0 = perfectly nice day; 0.0 = dark and gloomy\n        this.isSunny = true;\n        this.timeToChange = _tweakables__WEBPACK_IMPORTED_MODULE_1__[\"default\"].atmosphere.timeToTurnSunny;\n        this.clouds = [];\n        this.sunnyCloudTextures = [];\n        this.darkCloudTextures = [];\n        this.canvasManager = canvasManager;\n    }\n    get canvasWidth() {\n        return this.canvasManager.width;\n    }\n    get canvasHeight() {\n        return this.canvasManager.height;\n    }\n    makeItSunny() {\n        this.isSunny = true;\n        this.timeToChange = _tweakables__WEBPACK_IMPORTED_MODULE_1__[\"default\"].atmosphere.timeToTurnSunny;\n    }\n    makeItDark() {\n        this.isSunny = false;\n        this.timeToChange = _tweakables__WEBPACK_IMPORTED_MODULE_1__[\"default\"].atmosphere.timeToTurnDark;\n    }\n    addMoonTexture(moonTexture) {\n        this.moonTexture = moonTexture;\n    }\n    addCloudTextures(sunnyTexture, darkTexture) {\n        this.sunnyCloudTextures.push(sunnyTexture);\n        this.darkCloudTextures.push(darkTexture);\n    }\n    addBackgroundTextures(sunnyTexture, darkTexture) {\n        this.sunnyBackgroundTexture = sunnyTexture;\n        this.darkBackgroundTexture = darkTexture;\n    }\n    draw(sb) {\n        const view = this.canvasManager.viewableRegion;\n        const bottomOfSkyRight = { x: view.x2, y: _tweakables__WEBPACK_IMPORTED_MODULE_1__[\"default\"].net.center.y - _tweakables__WEBPACK_IMPORTED_MODULE_1__[\"default\"].net.height / 2 };\n        const ctr = _utils__WEBPACK_IMPORTED_MODULE_2__.vec.avg({ x: view.x1, y: view.y2 }, bottomOfSkyRight);\n        const dims = {\n            w: bottomOfSkyRight.x - view.x1,\n            h: view.y2 - bottomOfSkyRight.y,\n        };\n        sb.drawTextureCentered(this.sunnyBackgroundTexture, ctr, dims, 0, this.sunnyness);\n        sb.drawTextureCentered(this.darkBackgroundTexture, ctr, dims, 0, 1 - this.sunnyness);\n        const nightMoonHeight = view.y2 * _tweakables__WEBPACK_IMPORTED_MODULE_1__[\"default\"].moon.nightHeightFrac;\n        const dayMoonHeight = view.y1;\n        const moonHeight = nightMoonHeight - Math.sqrt(this.sunnyness) * (nightMoonHeight - dayMoonHeight);\n        const moonLoc = {\n            x: ctr.x + (1 - this.sunnyness) * (view.x2 - ctr.x) * _tweakables__WEBPACK_IMPORTED_MODULE_1__[\"default\"].moon.widthFrac,\n            y: moonHeight,\n        };\n        sb.drawTextureCentered(this.moonTexture, moonLoc, sb.autoDim(0.1, this.moonTexture), 0, 1);\n        for (const c of this.clouds) {\n            sb.drawTextureCentered(c.sunnyTexture, c.pos, sb.autoDim(c.width, c.sunnyTexture), 0, this.sunnyness);\n            sb.drawTextureCentered(c.darkTexture, c.pos, sb.autoDim(c.width, c.darkTexture), 0, 1 - this.sunnyness);\n        }\n    }\n    step(dt) {\n        if (this.isSunny && this.sunnyness < 1.0) {\n            this.sunnyness += dt / this.timeToChange;\n            this.sunnyness = Math.min(1, this.sunnyness);\n        }\n        else if (!this.isSunny && this.sunnyness > 0.0) {\n            this.sunnyness -= dt / this.timeToChange;\n            this.sunnyness = Math.max(0, this.sunnyness);\n        }\n        for (const c of this.clouds) {\n            c.step(dt);\n        }\n    }\n    fillClouds() {\n        const t = _tweakables__WEBPACK_IMPORTED_MODULE_1__[\"default\"];\n        const vMin = t.cloud.minVel;\n        const vMax = t.cloud.maxVel;\n        for (let i = 0; i < this.numClouds; i++) {\n            const sunny = this.sunnyCloudTextures[i % this.sunnyCloudTextures.length];\n            const dark = this.darkCloudTextures[i % this.darkCloudTextures.length];\n            const vx = vMax.x + Math.random() * (vMax.x - vMin.x);\n            const vy = vMin.y + Math.random() * (vMax.y - vMin.y);\n            const vel = { x: vx, y: vy };\n            const width = sunny.width / 1000;\n            const rect = {\n                x1: t.leftWall.center.x - 1.5,\n                x2: t.rightWall.center.x + 1.5,\n                y1: t.leftWall.center.y - t.leftWall.height / 2,\n                y2: t.rightWall.center.y + t.rightWall.height / 2,\n            };\n            this.clouds.push(new _cloud__WEBPACK_IMPORTED_MODULE_0__.Cloud(rect, sunny, dark, vel, { x: 0, y: 0 }, width));\n        }\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/atmosphere.ts?");

/***/ }),

/***/ "./src/ball.ts":
/*!*********************!*\
  !*** ./src/ball.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Ball\": () => (/* binding */ Ball)\n/* harmony export */ });\n/* harmony import */ var _circular_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./circular-object */ \"./src/circular-object.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\n\n\nclass Ball {\n    constructor(center, vel, diameter, mass, maxSpeed, orientation, angularVel, isAlive) {\n        this.physics = new _circular_object__WEBPACK_IMPORTED_MODULE_0__.CircularObject(center, vel, diameter, mass, orientation, angularVel, 1.0);\n        this.maxSpeed = maxSpeed;\n        this.isAlive = isAlive;\n    }\n    deepCopy() {\n        return new Ball(_utils__WEBPACK_IMPORTED_MODULE_1__.vec.copy(this.physics.center), _utils__WEBPACK_IMPORTED_MODULE_1__.vec.copy(this.physics.vel), this.physics.diameter, this.physics.mass, this.maxSpeed, this.physics.orientation, this.physics.angularVel, this.isAlive);\n    }\n    trimSpeedIfNecessary() {\n        const v = this.physics.vel;\n        if (_utils__WEBPACK_IMPORTED_MODULE_1__.vec.lenSq(v) > this.maxSpeed * this.maxSpeed) {\n            this.physics.vel = _utils__WEBPACK_IMPORTED_MODULE_1__.vec.scale(_utils__WEBPACK_IMPORTED_MODULE_1__.vec.normalized(v), this.maxSpeed);\n        }\n    }\n    stepVelocity(dt, gravity, trimSpeedIfNecessary) {\n        const shift = _utils__WEBPACK_IMPORTED_MODULE_1__.vec.scale(gravity, dt * this.physics.gravityMultiplier);\n        this.physics.vel = _utils__WEBPACK_IMPORTED_MODULE_1__.vec.add(this.physics.vel, shift);\n        if (trimSpeedIfNecessary)\n            this.trimSpeedIfNecessary();\n    }\n    stepPositionAndOrientation(dt) {\n        const centerShift = _utils__WEBPACK_IMPORTED_MODULE_1__.vec.scale(this.physics.vel, dt);\n        this.physics.center = _utils__WEBPACK_IMPORTED_MODULE_1__.vec.add(this.physics.center, centerShift);\n        this.physics.orientation += dt * this.physics.angularVel;\n    }\n    setAngularVel(av) {\n        this.physics.angularVel = av;\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/ball.ts?");

/***/ }),

/***/ "./src/canvas-manager.ts":
/*!*******************************!*\
  !*** ./src/canvas-manager.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CanvasManager\": () => (/* binding */ CanvasManager)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"./src/constants.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\n\n\nclass CanvasManager {\n    constructor(parentEl) {\n        // TODO move to tweakables\n        this.minZoomLevel = 0.45;\n        this.maxZoomLevel = 0.8;\n        this.zoomSpringConstant = 1;\n        this.startZoomScale = this.maxZoomLevel; // higher number = can see more\n        this.center = { x: 0.5, y: 0.3 };\n        this._zoomScale = this.startZoomScale;\n        this.parentEl = parentEl;\n        this._currViewRegion = { x1: -Infinity, x2: Infinity, y1: -Infinity, y2: Infinity };\n        this._currOnePixel = 1;\n        this._currInverseTransform = new DOMMatrix();\n    }\n    initialDraw() {\n        this.generateCanvas();\n        this.recalcCtxTransform();\n    }\n    recalcCtxTransform() {\n        const cw = this.canvas.width;\n        const ch = this.canvas.height;\n        const unitScale = Math.min(ch / 2, cw / 2);\n        this.ctx.resetTransform();\n        this.ctx.transform(1, 0, 0, -1, 0, ch); // flip y-axis\n        this.ctx.translate(cw / 2, ch / 2); // re-center to middle\n        this.ctx.scale(unitScale, unitScale); // scale to unit\n        this.ctx.translate(-this.center.x / this.zoomScale, -this.center.y / this.zoomScale); // now shift to desired center\n        this.ctx.scale(1 / this.zoomScale, 1 / this.zoomScale); // scale from there\n        const topLeft = this.pixelToCanvasPos({ x: 0, y: 0 });\n        const bottomRight = this.pixelToCanvasPos({ x: this.width, y: this.height });\n        this._currViewRegion = { x1: topLeft.x, x2: bottomRight.x, y1: bottomRight.y, y2: topLeft.y };\n        this._currOnePixel = this.pixelToCanvasPos({ x: 1, y: 1 }).x - this.pixelToCanvasPos({ x: 0, y: 0 }).x;\n        this._currInverseTransform = this.ctx.getTransform().inverse();\n    }\n    get viewableRegion() {\n        return this._currViewRegion;\n    }\n    get onePixel() {\n        return this._currOnePixel;\n    }\n    get zoomScale() {\n        return this._zoomScale;\n    }\n    get ctx() {\n        return this._ctx;\n    }\n    get width() {\n        return this.canvas.width;\n    }\n    get height() {\n        return this.canvas.height;\n    }\n    clearCanvas() {\n        this.ctx.save();\n        this.ctx.beginPath();\n        this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        this.ctx.restore();\n    }\n    generateCanvas() {\n        this.parentEl.innerHTML = '';\n        this.canvas = document.createElement('canvas');\n        this.canvas.className = 'game-canvas';\n        this.parentEl.append(this.canvas);\n        this._ctx = this.canvas.getContext('2d');\n        this.canvas.style.opacity = '1.0';\n        this.setCanvasDims();\n        window.addEventListener('resize', () => this.onWindowResize());\n    }\n    setCanvasDims() {\n        const c = this.canvas;\n        const w = this.parentEl.offsetWidth;\n        const h = this.parentEl.offsetHeight;\n        c.width = w * _constants__WEBPACK_IMPORTED_MODULE_0__[\"default\"].dpr;\n        c.height = h * _constants__WEBPACK_IMPORTED_MODULE_0__[\"default\"].dpr;\n        c.style.width = `${w}px`;\n        c.style.height = `${h}px`;\n        this.recalcCtxTransform();\n    }\n    onWindowResize() {\n        this.setCanvasDims();\n        this.recalcCtxTransform();\n    }\n    pixelToCanvasPos(p) {\n        return _utils__WEBPACK_IMPORTED_MODULE_1__.vec.transform(p, this._currInverseTransform);\n    }\n    canvasToPixelPos(p) {\n        return _utils__WEBPACK_IMPORTED_MODULE_1__.vec.transform(p, this.ctx.getTransform());\n    }\n    pixelWidth(pixels) {\n        return this._currOnePixel * pixels;\n    }\n    adjustZoomLevel(maxBallHeight, dt) {\n        let idealZoomLevel = 1.05 * maxBallHeight;\n        if (idealZoomLevel > this.maxZoomLevel)\n            idealZoomLevel = this.maxZoomLevel;\n        else if (idealZoomLevel < this.minZoomLevel)\n            idealZoomLevel = this.minZoomLevel;\n        this._zoomScale += (idealZoomLevel - this.zoomScale) * dt * this.zoomSpringConstant;\n        this.recalcCtxTransform();\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/canvas-manager.ts?");

/***/ }),

/***/ "./src/circular-object.ts":
/*!********************************!*\
  !*** ./src/circular-object.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CircularObject\": () => (/* binding */ CircularObject)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\n\nclass CircularObject {\n    constructor(center, vel, diameter, mass, orientation, angularVel, gravityMultiplier) {\n        this.center = center;\n        this.angularVel = angularVel;\n        this.vel = vel;\n        this.diameter = diameter;\n        this.orientation = orientation;\n        this.mass = mass;\n        this.gravityMultiplier = gravityMultiplier;\n    }\n    getBallMaxHeight(gravity) {\n        const vy = this.vel.y;\n        const py = this.center.y;\n        const energyPermass = py * -gravity.y + (vy * vy) / 2;\n        const maxHeight = energyPermass / -gravity.y;\n        return maxHeight;\n    }\n    handleHittingOtherCircle(other, elasticity) {\n        const result = {\n            didCollide: false,\n            angle: 0,\n            pointOfContact: { x: Infinity, y: Infinity },\n            c1MomentumDelta: { x: Infinity, y: Infinity },\n            c2MomentumDelta: { x: Infinity, y: Infinity },\n            c1EnergyDelta: Infinity,\n            c2EnergyDelta: Infinity,\n        };\n        // Exit early if their rectangles don't overlap\n        const thisRadius = this.diameter / 2;\n        const otherRadius = other.diameter / 2;\n        if (this.center.x + thisRadius < other.center.x - otherRadius ||\n            this.center.x - thisRadius > other.center.x + otherRadius ||\n            this.center.y + thisRadius < other.center.y - otherRadius ||\n            this.center.y - thisRadius > other.center.y + otherRadius)\n            return result;\n        const ed = elasticity; // elasticity\n        const displacement = _utils__WEBPACK_IMPORTED_MODULE_0__.vec.sub(this.center, other.center);\n        const distance = _utils__WEBPACK_IMPORTED_MODULE_0__.vec.len(displacement);\n        if (distance < this.diameter / 2 + other.diameter / 2) {\n            const a = _utils__WEBPACK_IMPORTED_MODULE_0__.vec.scale(displacement, 1 / distance);\n            const va1 = this.vel.x * a.x + this.vel.y * a.y;\n            const vb1 = -this.vel.x * a.y + this.vel.y * a.x;\n            const va2 = other.vel.x * a.x + other.vel.y * a.y;\n            const vb2 = -other.vel.x * a.y + other.vel.y * a.x;\n            const vaP1 = va1 + ((1 + ed) * (va2 - va1)) / (1 + this.mass / other.mass);\n            const vaP2 = va2 + ((1 + ed) * (va1 - va2)) / (1 + other.mass / this.mass);\n            const thisOldEnergy = 0.5 * this.mass * _utils__WEBPACK_IMPORTED_MODULE_0__.vec.lenSq(this.vel);\n            const otherOldEnergy = 0.5 * other.mass * _utils__WEBPACK_IMPORTED_MODULE_0__.vec.lenSq(other.vel);\n            const thisOldMomentum = _utils__WEBPACK_IMPORTED_MODULE_0__.vec.scale(this.vel, this.mass);\n            const otherOldMomentum = _utils__WEBPACK_IMPORTED_MODULE_0__.vec.scale(other.vel, other.mass);\n            this.vel.x = vaP1 * a.x - vb1 * a.y;\n            this.vel.y = vaP1 * a.y + vb1 * a.x;\n            other.vel.x = vaP2 * a.x - vb2 * a.y;\n            other.vel.y = vaP2 * a.y + vb2 * a.x;\n            const thisNewEnergy = 0.5 * this.mass * _utils__WEBPACK_IMPORTED_MODULE_0__.vec.lenSq(this.vel);\n            const otherNewEnergy = 0.5 * other.mass * _utils__WEBPACK_IMPORTED_MODULE_0__.vec.lenSq(other.vel);\n            const thisNewMomentum = _utils__WEBPACK_IMPORTED_MODULE_0__.vec.scale(this.vel, this.mass);\n            const otherNewMomentum = _utils__WEBPACK_IMPORTED_MODULE_0__.vec.scale(other.vel, other.mass);\n            // Finally, make sure displacement is at least radii.\n            const appropriateSeparation = 1.0 * (this.diameter / 2 + other.diameter / 2);\n            if (distance < appropriateSeparation && this.mass > other.mass) {\n                const toSub = _utils__WEBPACK_IMPORTED_MODULE_0__.vec.scale(a, appropriateSeparation - distance);\n                other.center = _utils__WEBPACK_IMPORTED_MODULE_0__.vec.sub(other.center, toSub);\n            }\n            else if (distance < appropriateSeparation && this.mass <= other.mass) {\n                const toAdd = _utils__WEBPACK_IMPORTED_MODULE_0__.vec.scale(a, appropriateSeparation - distance);\n                this.center = _utils__WEBPACK_IMPORTED_MODULE_0__.vec.add(this.center, toAdd);\n            }\n            result.pointOfContact = _utils__WEBPACK_IMPORTED_MODULE_0__.vec.add(other.center, _utils__WEBPACK_IMPORTED_MODULE_0__.vec.scale(a, other.diameter / 2));\n            result.angle = Math.atan2(a.y, a.x);\n            result.c1EnergyDelta = thisNewEnergy - thisOldEnergy;\n            result.c2EnergyDelta = otherNewEnergy - otherOldEnergy;\n            result.c1MomentumDelta = _utils__WEBPACK_IMPORTED_MODULE_0__.vec.sub(thisNewMomentum, thisOldMomentum);\n            result.c2MomentumDelta = _utils__WEBPACK_IMPORTED_MODULE_0__.vec.sub(otherNewMomentum, otherOldMomentum);\n            result.didCollide = true;\n            return result;\n        }\n        else {\n            result.didCollide = false;\n            return result;\n        }\n    }\n    handleHittingPoint(point, elasticity) {\n        const displacement = _utils__WEBPACK_IMPORTED_MODULE_0__.vec.sub(point, this.center);\n        const distance = _utils__WEBPACK_IMPORTED_MODULE_0__.vec.len(displacement);\n        if (distance < this.diameter / 2) {\n            const displacementNormal = _utils__WEBPACK_IMPORTED_MODULE_0__.vec.normalized(displacement);\n            const velTowardCollision = _utils__WEBPACK_IMPORTED_MODULE_0__.vec.scale(displacementNormal, _utils__WEBPACK_IMPORTED_MODULE_0__.vec.dotProduct(this.vel, displacementNormal));\n            const velPerpendicularToCollision = _utils__WEBPACK_IMPORTED_MODULE_0__.vec.sub(this.vel, velTowardCollision);\n            this.vel = _utils__WEBPACK_IMPORTED_MODULE_0__.vec.add(velPerpendicularToCollision, _utils__WEBPACK_IMPORTED_MODULE_0__.vec.scale(velTowardCollision, -1 * elasticity));\n            this.center = _utils__WEBPACK_IMPORTED_MODULE_0__.vec.sub(point, _utils__WEBPACK_IMPORTED_MODULE_0__.vec.scale(displacementNormal, this.diameter / 2));\n            // For now, cut rotational speed in half\n            this.angularVel /= 2;\n            return true;\n        }\n        return false;\n    }\n    handleHittingVerticalSegment(lowerPoint, upperPoint, elasticity) {\n        if (this.center.y >= lowerPoint.y && this.center.y <= upperPoint.y) {\n            const displacementFromCenter = lowerPoint.x - this.center.x;\n            // if ball hitting, coming from the left\n            if (displacementFromCenter > 0 && displacementFromCenter < this.diameter / 2 && this.vel.x > 0) {\n                this.vel.x *= -elasticity;\n                this.center.x = lowerPoint.x - this.diameter / 2;\n                // For now, cut rotational speed arbitrarily\n                this.angularVel /= 2;\n                return true;\n            }\n            // ball hitting, coming from the right\n            else if (displacementFromCenter < 0 && displacementFromCenter > -this.diameter / 2 && this.vel.x < 0) {\n                this.vel.x *= -elasticity;\n                this.center.x = lowerPoint.x + this.diameter / 2;\n                // For now, cut rotational speed arbitrarily\n                this.angularVel /= 2;\n                return true;\n            }\n        }\n        return false;\n    }\n    handleHittingHorizontalSegment(leftPoint, rightPoint, elasticity) {\n        if (this.center.x >= leftPoint.x && this.center.x <= rightPoint.x) {\n            const displacementFromCenter = leftPoint.y - this.center.y;\n            // if ball hitting, coming from the bottom\n            if (displacementFromCenter > 0 && displacementFromCenter < this.diameter / 2 && this.vel.y > 0) {\n                this.vel.y *= -elasticity;\n                this.center.y = leftPoint.y - this.diameter / 2;\n                // For now, cut rotational speed arbitrarily\n                this.angularVel /= 2;\n                return true;\n            }\n            // ball hitting, coming from the top\n            else if (displacementFromCenter < 0 && displacementFromCenter > -this.diameter / 2 && this.vel.y < 0) {\n                this.vel.y *= -elasticity;\n                this.center.y = leftPoint.y + this.diameter / 2;\n                // For now, cut rotational speed arbitrarily\n                this.angularVel /= 2;\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/circular-object.ts?");

/***/ }),

/***/ "./src/cloud.ts":
/*!**********************!*\
  !*** ./src/cloud.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Cloud\": () => (/* binding */ Cloud)\n/* harmony export */ });\nclass Cloud {\n    // Public Methods\n    constructor(constraint, sunnyTexture, darkTexture, vel, pos, width) {\n        this._age = 0;\n        this._constraint = constraint;\n        this._sunnyTexture = sunnyTexture;\n        this._darkTexture = darkTexture;\n        this._vel = vel;\n        this._pos = pos;\n        this._width = width;\n    }\n    get width() {\n        return this._width;\n    }\n    get sunnyTexture() {\n        return this._sunnyTexture;\n    }\n    get darkTexture() {\n        return this._darkTexture;\n    }\n    get age() {\n        return this._age;\n    }\n    get pos() {\n        return this._pos;\n    }\n    step(dt) {\n        const c = this._constraint;\n        this._pos.x += this._vel.x * dt;\n        this._pos.y += this._vel.y * dt;\n        if (this._vel.x < 0 && this._pos.x < c.x1)\n            this._pos.x = c.x2;\n        if (this._vel.x > 0 && this._pos.x > c.x2)\n            this._pos.x = c.x1;\n        if (this._vel.y < 0 && this._pos.y < c.y1)\n            this._pos.y = c.y2;\n        if (this._vel.y > 0 && this._pos.y > c.y2)\n            this._pos.y = c.y1;\n        if (this._pos.y > c.y2) {\n            this._pos.y = c.y2;\n            this._vel.y = -Math.abs(this._vel.y);\n        }\n        if (this._pos.y < c.y1) {\n            this._pos.y = c.y1;\n            this._vel.y = Math.abs(this._vel.y);\n        }\n        this._age += dt;\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/cloud.ts?");

/***/ }),

/***/ "./src/color.ts":
/*!**********************!*\
  !*** ./src/color.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Color\": () => (/* binding */ Color),\n/* harmony export */   \"Colors\": () => (/* binding */ Colors)\n/* harmony export */ });\nclass Color {\n    constructor(r, g, b, a) {\n        if (typeof a !== 'number' || isNaN(a))\n            throw new Error(`I demand alpha.`);\n        this.r = r;\n        this.g = g;\n        this.b = b;\n        this.a = a;\n    }\n    toHtmlRgb() {\n        return `rgba(${this.r * 255},${this.g * 255},${this.b * 255},${this.a})`;\n    }\n}\nconst Colors = {\n    white: new Color(1, 1, 1, 1),\n    black: new Color(0, 0, 0, 1),\n};\n\n\n\n//# sourceURL=webpack:///./src/color.ts?");

/***/ }),

/***/ "./src/constants.ts":
/*!**************************!*\
  !*** ./src/constants.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar _a;\nconst c = {\n    gameLoopDelayMs: 5,\n    expressPort: 3377,\n    assetUrl: `http://localhost:3377/public/`,\n    dpr: (_a = window.devicePixelRatio) !== null && _a !== void 0 ? _a : 1,\n    link: 'https://chriscoyne.com',\n    version: '0.1.1',\n    versionDateStr: '23-Jan-2023',\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (c);\n\n\n//# sourceURL=webpack:///./src/constants.ts?");

/***/ }),

/***/ "./src/content-loader.ts":
/*!*******************************!*\
  !*** ./src/content-loader.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ContentLoader\": () => (/* binding */ ContentLoader)\n/* harmony export */ });\n/* harmony import */ var _sound_effect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sound-effect */ \"./src/sound-effect.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\nclass ContentLoader {\n    constructor(loadMonitor) {\n        this.loadStats = { total: 0, done: 0 };\n        this.audioContext = new AudioContext();\n        this.loadMonitor = loadMonitor;\n    }\n    loadFont(familyName, url, weight) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.loadStats.total++;\n            const ffd = { weight: `${weight}` };\n            const ff = new FontFace(`${familyName}`, `url(${url})`, ffd);\n            document.fonts.add(ff);\n            yield ff.load();\n            this.loadStats.done++;\n            return ff;\n        });\n    }\n    loadImage(url) {\n        this.loadStats.total++;\n        this.loadMonitor(this.getLoadStats());\n        return new Promise((resolve, reject) => {\n            this.loadStats.done++;\n            const img = new Image();\n            img.onload = () => resolve(img);\n            img.onerror = reject;\n            img.src = url;\n            this.loadMonitor(this.getLoadStats());\n        });\n    }\n    loadTexture2d(url) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.loadStats.total++;\n            this.loadMonitor(this.getLoadStats());\n            const img = yield this.loadImage(url);\n            this.loadStats.done++;\n            const res = {\n                width: img.width,\n                height: img.height,\n                img: img,\n            };\n            if (isNaN(img.width) || img.width === 0) {\n                throw new Error(`Could not load image asset ${url}`);\n            }\n            this.loadMonitor(this.getLoadStats());\n            return res;\n        });\n    }\n    loadSoundEffect(path) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.loadStats.total++;\n            this.loadMonitor(this.getLoadStats());\n            const response = yield window.fetch(path);\n            const arrBuffer = yield response.arrayBuffer();\n            const audioBuffer = yield this.audioContext.decodeAudioData(arrBuffer);\n            this.loadStats.done++;\n            this.loadMonitor(this.getLoadStats());\n            return new _sound_effect__WEBPACK_IMPORTED_MODULE_0__.SoundEffect(audioBuffer, this.audioContext);\n        });\n    }\n    getLoadStats() {\n        return {\n            done: this.loadStats.done,\n            total: this.loadStats.total,\n        };\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/content-loader.ts?");

/***/ }),

/***/ "./src/display.ts":
/*!************************!*\
  !*** ./src/display.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Display\": () => (/* binding */ Display)\n/* harmony export */ });\n/* harmony import */ var _ai_black_ai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ai/black-ai */ \"./src/ai/black-ai.ts\");\n/* harmony import */ var _ai_green_ai__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ai/green-ai */ \"./src/ai/green-ai.ts\");\n/* harmony import */ var _ai_purple_ai__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ai/purple-ai */ \"./src/ai/purple-ai.ts\");\n/* harmony import */ var _ai_white_ai__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ai/white-ai */ \"./src/ai/white-ai.ts\");\n/* harmony import */ var _atmosphere__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./atmosphere */ \"./src/atmosphere.ts\");\n/* harmony import */ var _canvas_manager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./canvas-manager */ \"./src/canvas-manager.ts\");\n/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./color */ \"./src/color.ts\");\n/* harmony import */ var _font_manager__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./font-manager */ \"./src/font-manager.ts\");\n/* harmony import */ var _game__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./game */ \"./src/game.ts\");\n/* harmony import */ var _kapow_manager__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./kapow-manager */ \"./src/kapow-manager.ts\");\n/* harmony import */ var _player__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./player */ \"./src/player.ts\");\n/* harmony import */ var _score_card__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./score-card */ \"./src/score-card.ts\");\n/* harmony import */ var _sprite_batch__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./sprite-batch */ \"./src/sprite-batch.ts\");\n/* harmony import */ var _tweakables__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./tweakables */ \"./src/tweakables.ts\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst textureSources = {\n    ball1: 'images/Volleyball1.png',\n    ball2: 'images/Volleyball2.png',\n    ballShadow: 'images/BallShadow.png',\n    net: 'images/Net.png',\n    redPlayer: 'images/Players/RedPlayer.png',\n    greenPlayer: 'images/Players/GreenPlayer.png',\n    purplePlayer: 'images/Players/PurplePlayer.png',\n    whitePlayer: 'images/Players/WhitePlayer.png',\n    blackPlayer: 'images/Players/BlackPlayer.png',\n    bluePlayer: 'images/Players/BluePlayer.png',\n    pupil: 'images/Players/Pupil.png',\n    pupilGray: 'images/Players/PupilGray.png',\n    scoreCard: 'images/ScoreCard.png',\n    leftFlower: 'images/FlowerLeft.png',\n    rightFlower: 'images/FlowerRight.png',\n    leftFlowerTop: 'images/FlowerTop1.png',\n    rightFlowerTop: 'images/FlowerTop2.png',\n    floorFront: 'images/FloorFront.png',\n    floorBack: 'images/FloorBack.png',\n    playerShadowBehind: 'images/PlayerShadowBehind.png',\n    playerShadowFront: 'images/PlayerShadowFront.png',\n    gamepad: 'images/Gamepad.png',\n    keyboard: 'images/Keyboard.png',\n    moon: 'images/Atmosphere/Moon.png',\n    predictionDot: 'images/PredictionDot.png',\n    kapowSlam: 'images/Kapows/KapowSlam.png',\n    kapowRejected: 'images/Kapows/KapowRejected.png',\n    kapowScore: 'images/Kapows/KapowScore.png',\n    sunnyCloud1: 'images/Atmosphere/SunnyCloud1.png',\n    darkCloud1: 'images/Atmosphere/DarkCloud1.png',\n    sunnyCloud2: 'images/Atmosphere/SunnyCloud2.png',\n    darkCloud2: 'images/Atmosphere/DarkCloud2.png',\n    sunnyCloud3: 'images/Atmosphere/SunnyCloud3.png',\n    darkCloud3: 'images/Atmosphere/DarkCloud3.png',\n    sunnyCloud4: 'images/Atmosphere/SunnyCloud4.png',\n    darkCloud4: 'images/Atmosphere/DarkCloud4.png',\n    sunnyCloud5: 'images/Atmosphere/SunnyCloud5.png',\n    darkCloud5: 'images/Atmosphere/DarkCloud5.png',\n    sunnyBackground: 'images/Atmosphere/SunnyBackground.png',\n    darkBackground: 'images/Atmosphere/DarkBackground.png',\n    menuDivider: 'images/MenuDivider.png',\n    menuBanner2Player1Ball: 'images/MenuBanners/MenuBanner2P1.png',\n    menuBanner2Player2Balls: 'images/MenuBanners/MenuBanner2P2.png',\n    menuBannerGreen: 'images/MenuBanners/MenuBannerGreen.png',\n    menuBannerBlack: 'images/MenuBanners/MenuBannerBlack.png',\n    menuBannerWhite: 'images/MenuBanners/MenuBannerWhite.png',\n    menuBannerPurple: 'images/MenuBanners/MenuBannerPurple.png',\n};\nclass Display {\n    constructor(content, targetDiv) {\n        this.textures = new Map();\n        this.lastCloudDraw = 0;\n        this.inDebugView = false;\n        this.content = content;\n        this.canvasManager = new _canvas_manager__WEBPACK_IMPORTED_MODULE_5__.CanvasManager(targetDiv);\n        this.spriteBatch = new _sprite_batch__WEBPACK_IMPORTED_MODULE_12__.SpriteBatch(this.canvasManager);\n        this.atmosphere = new _atmosphere__WEBPACK_IMPORTED_MODULE_4__.Atmosphere(this.canvasManager);\n        this.p0ScoreCard = new _score_card__WEBPACK_IMPORTED_MODULE_11__.ScoreCard();\n        this.p1ScoreCard = new _score_card__WEBPACK_IMPORTED_MODULE_11__.ScoreCard();\n        this._fontManager = new _font_manager__WEBPACK_IMPORTED_MODULE_7__.FontManager(this.content);\n    }\n    loadTexture(path, name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const t = yield this.content.loadTexture2d(path);\n            this.textures.set(name, t);\n        });\n    }\n    font(fontName) {\n        return this._fontManager.getFont(fontName);\n    }\n    get canvasWidth() {\n        return this.canvasManager.width;\n    }\n    get canvasHeight() {\n        return this.canvasManager.height;\n    }\n    get ctx() {\n        return this.canvasManager.ctx;\n    }\n    getSpriteBatch() {\n        return this.spriteBatch;\n    }\n    initialDraw() {\n        this.canvasManager.initialDraw();\n    }\n    loadContent() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.spriteBatch = new _sprite_batch__WEBPACK_IMPORTED_MODULE_12__.SpriteBatch(this.canvasManager);\n            const p = [];\n            Object.entries(textureSources).forEach(([name, source]) => p.push(this.loadTexture(source, name)));\n            p.push(this._fontManager.loadContent());\n            yield Promise.all(p);\n            this.atmosphere.addBackgroundTextures(this.getTexture('sunnyBackground'), this.getTexture('darkBackground'));\n            for (let i = 1; i <= 5; i++) {\n                const tSunny = this.getTexture(`sunnyCloud${i}`);\n                const tDark = this.getTexture(`darkCloud${i}`);\n                this.atmosphere.addCloudTextures(tSunny, tDark);\n            }\n            this.atmosphere.fillClouds();\n            this.atmosphere.addMoonTexture(this.getTexture('moon'));\n        });\n    }\n    getTexture(name) {\n        const t = this.textures.get(name);\n        if (!t)\n            throw new Error(`no texture was loaded with name ${name}`);\n        return t;\n    }\n    bounceScoreCard(playerSide) {\n        if (playerSide == _types__WEBPACK_IMPORTED_MODULE_14__.PlayerSide.Left)\n            this.p0ScoreCard.bounce();\n        else\n            this.p1ScoreCard.bounce();\n    }\n    drawPlayer(gameTime, playerSide, player, playerConfig, playerTexture, ball) {\n        const isSkarball = playerConfig.species === _player__WEBPACK_IMPORTED_MODULE_10__.PlayerSpecies.Ai && playerConfig.ai instanceof _ai_white_ai__WEBPACK_IMPORTED_MODULE_3__.WhiteAi;\n        const leftEyeOffset = _utils__WEBPACK_IMPORTED_MODULE_15__.vec.scale({ x: -0.113, y: 0.14 }, player.physics.diameter);\n        const rightEyeOffset = _utils__WEBPACK_IMPORTED_MODULE_15__.vec.scale({ x: 0.1195, y: 0.144 }, player.physics.diameter);\n        let leftEyePosition = _utils__WEBPACK_IMPORTED_MODULE_15__.vec.add(player.physics.center, leftEyeOffset);\n        let rightEyePosition = _utils__WEBPACK_IMPORTED_MODULE_15__.vec.add(player.physics.center, rightEyeOffset);\n        const leftEyeWidth = 0.24 * 0.67 * player.physics.diameter;\n        const rightEyeWidth = 0.28 * 0.67 * player.physics.diameter;\n        let leftEyeHeight = leftEyeWidth;\n        let rightEyeHeight = rightEyeWidth;\n        const blinkFactor = playerSide === _types__WEBPACK_IMPORTED_MODULE_14__.PlayerSide.Left ? 0 : 1;\n        if (gameTime.totalGameTime.totalMilliseconds % (5000 + blinkFactor * 1000) < 200) {\n            // blink\n            leftEyeHeight *= 0.1;\n            rightEyeHeight *= isSkarball ? 1 : 0.1;\n        }\n        let leftEyeBallDirection = _utils__WEBPACK_IMPORTED_MODULE_15__.vec.sub(ball.physics.center, leftEyePosition);\n        let rightEyeBallDirection = _utils__WEBPACK_IMPORTED_MODULE_15__.vec.sub(ball.physics.center, rightEyePosition);\n        const leftEyeRange = 0.05;\n        const rightEyeRange = isSkarball ? leftEyeRange / 2 : leftEyeRange;\n        leftEyeBallDirection = _utils__WEBPACK_IMPORTED_MODULE_15__.vec.normalized(leftEyeBallDirection);\n        rightEyeBallDirection = _utils__WEBPACK_IMPORTED_MODULE_15__.vec.normalized(rightEyeBallDirection);\n        leftEyePosition = _utils__WEBPACK_IMPORTED_MODULE_15__.vec.add(leftEyePosition, _utils__WEBPACK_IMPORTED_MODULE_15__.vec.scale(leftEyeBallDirection, player.physics.diameter * leftEyeRange));\n        rightEyePosition = _utils__WEBPACK_IMPORTED_MODULE_15__.vec.add(rightEyePosition, _utils__WEBPACK_IMPORTED_MODULE_15__.vec.scale(rightEyeBallDirection, player.physics.diameter * rightEyeRange));\n        this.spriteBatch.drawTextureCentered(playerTexture, player.physics.center, { w: player.physics.diameter, h: player.physics.diameter }, 0, 1);\n        const pupil = this.getTexture('pupil');\n        const pupilGray = this.getTexture('pupilGray');\n        this.spriteBatch.drawTextureCentered(pupil, leftEyePosition, { w: leftEyeWidth, h: leftEyeHeight }, 0, 1);\n        const rightPupil = isSkarball ? pupilGray : pupil;\n        this.spriteBatch.drawTextureCentered(rightPupil, rightEyePosition, { w: rightEyeWidth, h: rightEyeHeight }, 0, 1);\n    }\n    drawPlayerShadowBehind(player) {\n        const shadowWidth = player.physics.diameter * 1.1;\n        const shadowHeight = player.physics.diameter / 5;\n        const shadowPosition = { x: player.physics.center.x, y: 0 };\n        this.spriteBatch.drawTextureCentered(this.getTexture('playerShadowBehind'), shadowPosition, { w: shadowWidth, h: shadowHeight }, 0, 1);\n    }\n    drawPlayerShadowFront(player) {\n        const shadowWidth = player.physics.diameter * 1.1;\n        const shadowHeight = player.physics.diameter / 10;\n        const shadowPosition = { x: player.physics.center.x, y: -shadowHeight / 2 };\n        this.spriteBatch.drawTextureCentered(this.getTexture('playerShadowFront'), shadowPosition, { w: shadowWidth, h: shadowHeight }, 0, 1);\n    }\n    drawCenteredDancingMessage(gameTime, text, subtitle, color) {\n        const minHeight = 0.08;\n        const maxHeight = 0.25; // added or subtracted to above\n        const avgHeight = (maxHeight + minHeight) / 2;\n        const heightDev = avgHeight - minHeight;\n        const seconds = gameTime.totalGameTime.totalSeconds;\n        const beat = Math.PI * 2.0 * seconds * (_tweakables__WEBPACK_IMPORTED_MODULE_13__[\"default\"].menu.bpm / 60);\n        const height = avgHeight + heightDev * (Math.sin(beat / 2) / 2 + Math.sin(beat / 8) / 2);\n        const rot = -0.1 + Math.sin(beat) / 50.0;\n        const destination = { x: 0.5, y: 0.4 };\n        const shift = this.canvasManager.pixelWidth(2);\n        const subFont = this.font('regular');\n        const font = this.font('extraBold');\n        // we draw subtitle first so title is on top when they overlap\n        if (subtitle) {\n            const subtitleRelativeSize = 0.8; // 80% as big as title\n            const subtitleSize = (minHeight + (maxHeight - height)) * subtitleRelativeSize;\n            destination.y -= subtitleSize * 2;\n            this.spriteBatch.drawStringCentered(subtitle, subFont, subtitleSize, _utils__WEBPACK_IMPORTED_MODULE_15__.vec.add(destination, { x: shift, y: shift }), _color__WEBPACK_IMPORTED_MODULE_6__.Colors.black, rot);\n            this.spriteBatch.drawStringCentered(subtitle, subFont, subtitleSize, _utils__WEBPACK_IMPORTED_MODULE_15__.vec.add(destination, { x: shift, y: -shift }), _color__WEBPACK_IMPORTED_MODULE_6__.Colors.black, rot);\n            this.spriteBatch.drawStringCentered(subtitle, subFont, subtitleSize, _utils__WEBPACK_IMPORTED_MODULE_15__.vec.add(destination, { x: -shift, y: shift }), _color__WEBPACK_IMPORTED_MODULE_6__.Colors.black, rot);\n            this.spriteBatch.drawStringCentered(subtitle, subFont, subtitleSize, _utils__WEBPACK_IMPORTED_MODULE_15__.vec.add(destination, { x: -shift, y: -shift }), _color__WEBPACK_IMPORTED_MODULE_6__.Colors.black, rot);\n            this.spriteBatch.drawStringCentered(subtitle, subFont, subtitleSize, destination, color, rot);\n            destination.y += subtitleSize;\n        }\n        this.spriteBatch.drawStringCentered(text, font, height, _utils__WEBPACK_IMPORTED_MODULE_15__.vec.add(destination, { x: shift, y: shift }), _color__WEBPACK_IMPORTED_MODULE_6__.Colors.black, rot);\n        this.spriteBatch.drawStringCentered(text, font, height, _utils__WEBPACK_IMPORTED_MODULE_15__.vec.add(destination, { x: shift, y: -shift }), _color__WEBPACK_IMPORTED_MODULE_6__.Colors.black, rot);\n        this.spriteBatch.drawStringCentered(text, font, height, _utils__WEBPACK_IMPORTED_MODULE_15__.vec.add(destination, { x: -shift, y: shift }), _color__WEBPACK_IMPORTED_MODULE_6__.Colors.black, rot);\n        this.spriteBatch.drawStringCentered(text, font, height, _utils__WEBPACK_IMPORTED_MODULE_15__.vec.add(destination, { x: -shift, y: -shift }), _color__WEBPACK_IMPORTED_MODULE_6__.Colors.black, rot);\n        this.spriteBatch.drawStringCentered(text, font, height, destination, color, rot);\n    }\n    getPlayerTexture(playerConfig, playerSide) {\n        if (playerSide == _types__WEBPACK_IMPORTED_MODULE_14__.PlayerSide.Left && playerConfig.species === _player__WEBPACK_IMPORTED_MODULE_10__.PlayerSpecies.Human)\n            return this.getTexture('redPlayer');\n        else if (playerSide == _types__WEBPACK_IMPORTED_MODULE_14__.PlayerSide.Right && playerConfig.species == _player__WEBPACK_IMPORTED_MODULE_10__.PlayerSpecies.Human)\n            return this.getTexture('bluePlayer');\n        else {\n            if (playerConfig.ai instanceof _ai_black_ai__WEBPACK_IMPORTED_MODULE_0__.BlackAi)\n                return this.getTexture('blackPlayer');\n            else if (playerConfig.ai instanceof _ai_green_ai__WEBPACK_IMPORTED_MODULE_1__.GreenAi)\n                return this.getTexture('greenPlayer');\n            else if (playerConfig.ai instanceof _ai_purple_ai__WEBPACK_IMPORTED_MODULE_2__.PurpleAi)\n                return this.getTexture('purplePlayer');\n            else\n                return this.getTexture('whitePlayer');\n        }\n    }\n    drawControllerInstructions() {\n        // TODO\n        const c = new _color__WEBPACK_IMPORTED_MODULE_6__.Color(1, 1, 1, 1);\n        this.spriteBatch.drawStringCentered('Instructions soon', this.font('regular'), 0.1, { x: 0.5, y: 0.1 }, c, 0);\n    }\n    drawCredits(gameTime) {\n        console.log(`Todo, draw credits at ${gameTime.totalGameTime.totalSeconds}`);\n    }\n    drawKapows(k) {\n        for (const kapow of k.kapows) {\n            let texture;\n            switch (kapow.kapowType) {\n                case _kapow_manager__WEBPACK_IMPORTED_MODULE_9__.KapowType.Slam:\n                    texture = this.getTexture('kapowSlam');\n                    break;\n                case _kapow_manager__WEBPACK_IMPORTED_MODULE_9__.KapowType.Rejected:\n                    texture = this.getTexture('kapowRejected');\n                    break;\n                case _kapow_manager__WEBPACK_IMPORTED_MODULE_9__.KapowType.Score:\n                    texture = this.getTexture('kapowScore');\n                    break;\n                default:\n                    texture = this.getTexture('kapowSlam');\n                    break;\n            }\n            const alpha = 1 - kapow.fractionOfWayToDeath();\n            this.spriteBatch.drawTextureCentered(texture, kapow.pos, { w: kapow.size, h: kapow.size }, kapow.orientation, alpha);\n        }\n    }\n    draw(gameTime, gameState, gameConfig, p0Score, p1Score, futurePrediction, kapowManager, currentFps, gamepadConnectSummary) {\n        var _a;\n        this.canvasManager.clearCanvas();\n        const playerTextures = new Map();\n        playerTextures.set(_types__WEBPACK_IMPORTED_MODULE_14__.PlayerSide.Left, this.getPlayerTexture(gameConfig.playerConfig(_types__WEBPACK_IMPORTED_MODULE_14__.PlayerSide.Left), _types__WEBPACK_IMPORTED_MODULE_14__.PlayerSide.Left));\n        playerTextures.set(_types__WEBPACK_IMPORTED_MODULE_14__.PlayerSide.Right, this.getPlayerTexture(gameConfig.playerConfig(_types__WEBPACK_IMPORTED_MODULE_14__.PlayerSide.Right), _types__WEBPACK_IMPORTED_MODULE_14__.PlayerSide.Right));\n        const dt = (gameTime.totalGameTime.totalMilliseconds - this.lastCloudDraw) / 1000.0;\n        this.p0ScoreCard.update(dt);\n        this.p1ScoreCard.update(dt);\n        this.atmosphere.step(dt);\n        this.lastCloudDraw = gameTime.totalGameTime.totalMilliseconds;\n        this.atmosphere.draw(this.spriteBatch);\n        //const topLeftCorner = this.canvasManager.topLeftCorner()\n        //const bottomRightCorner = this.canvasManager.bottomRightCorner()\n        const viewableRegion = this.canvasManager.viewableRegion;\n        //const floorBackDim = this.spriteBatch.autoDim(gameConfig.floorBack.width, this.floorBackTexture)\n        this.spriteBatch.drawTextureInRect(this.getTexture('floorBack'), {\n            x1: viewableRegion.x1,\n            x2: viewableRegion.x2,\n            y1: _tweakables__WEBPACK_IMPORTED_MODULE_13__[\"default\"].floorBack.yMin,\n            y2: _tweakables__WEBPACK_IMPORTED_MODULE_13__[\"default\"].floorBack.yMax,\n        }, 1);\n        if (gameState != _game__WEBPACK_IMPORTED_MODULE_8__.GameState.PreExitMessage &&\n            gameState != _game__WEBPACK_IMPORTED_MODULE_8__.GameState.Instructions &&\n            gameState != _game__WEBPACK_IMPORTED_MODULE_8__.GameState.Intro1 &&\n            gameState != _game__WEBPACK_IMPORTED_MODULE_8__.GameState.Intro2 &&\n            gameState != _game__WEBPACK_IMPORTED_MODULE_8__.GameState.Intro3 &&\n            gameState != _game__WEBPACK_IMPORTED_MODULE_8__.GameState.MainMenu) {\n            this.drawPlayerShadowBehind(gameConfig.player(_types__WEBPACK_IMPORTED_MODULE_14__.PlayerSide.Left));\n            this.drawPlayerShadowBehind(gameConfig.player(_types__WEBPACK_IMPORTED_MODULE_14__.PlayerSide.Right));\n            this.drawKapows(kapowManager);\n            for (const side of [_types__WEBPACK_IMPORTED_MODULE_14__.PlayerSide.Left, _types__WEBPACK_IMPORTED_MODULE_14__.PlayerSide.Right]) {\n                const player = gameConfig.player(side);\n                const playerConfig = gameConfig.playerConfig(side);\n                let closestBall = gameConfig.balls[0];\n                let closestDistance = Infinity;\n                for (const ball of gameConfig.balls) {\n                    if (ball.isAlive) {\n                        const distance = _utils__WEBPACK_IMPORTED_MODULE_15__.vec.lenSq(_utils__WEBPACK_IMPORTED_MODULE_15__.vec.sub(ball.physics.center, player.physics.center));\n                        if (distance < closestDistance) {\n                            closestDistance = distance;\n                            closestBall = ball;\n                        }\n                    }\n                }\n                const texture = (_a = playerTextures.get(side)) !== null && _a !== void 0 ? _a : this.getTexture('redPlayer');\n                this.drawPlayer(gameTime, side, player, playerConfig, texture, closestBall);\n            }\n            for (let i = 0; i < gameConfig.balls.length; i++) {\n                this.drawBall(gameConfig.balls[i], i);\n            }\n        }\n        this.spriteBatch.drawTextureInRect(this.getTexture('floorFront'), {\n            x1: viewableRegion.x1,\n            x2: viewableRegion.x2,\n            y1: viewableRegion.y1,\n            y2: _tweakables__WEBPACK_IMPORTED_MODULE_13__[\"default\"].floorFront.yMax,\n        }, 1);\n        if (gameState != _game__WEBPACK_IMPORTED_MODULE_8__.GameState.PreExitMessage &&\n            gameState != _game__WEBPACK_IMPORTED_MODULE_8__.GameState.Instructions &&\n            gameState != _game__WEBPACK_IMPORTED_MODULE_8__.GameState.Intro1 &&\n            gameState != _game__WEBPACK_IMPORTED_MODULE_8__.GameState.Intro2 &&\n            gameState != _game__WEBPACK_IMPORTED_MODULE_8__.GameState.Intro3 &&\n            gameState != _game__WEBPACK_IMPORTED_MODULE_8__.GameState.MainMenu) {\n            this.drawPlayerShadowFront(gameConfig.player(_types__WEBPACK_IMPORTED_MODULE_14__.PlayerSide.Left));\n            this.drawPlayerShadowFront(gameConfig.player(_types__WEBPACK_IMPORTED_MODULE_14__.PlayerSide.Right));\n        }\n        const leftTreeTopWidth = gameConfig.leftWall.width * 2.5;\n        const leftFlowerTop = this.getTexture('leftFlowerTop');\n        const rightFlowerTop = this.getTexture('rightFlowerTop');\n        const leftTreeTopHeight = (leftTreeTopWidth * leftFlowerTop.height) / leftFlowerTop.width;\n        const rightTreeTopWidth = gameConfig.rightWall.width * 2.5;\n        const rightTreeTopHeight = (rightTreeTopWidth * rightFlowerTop.height) / rightFlowerTop.width;\n        this.spriteBatch.drawTextureCentered(this.getTexture('net'), gameConfig.net.center, { w: gameConfig.net.width, h: gameConfig.net.height }, 0, 1);\n        this.drawFlowers(gameConfig, leftTreeTopWidth, leftTreeTopHeight, rightTreeTopWidth, rightTreeTopHeight);\n        if (gameState != _game__WEBPACK_IMPORTED_MODULE_8__.GameState.MainMenu &&\n            gameState != _game__WEBPACK_IMPORTED_MODULE_8__.GameState.PreStart &&\n            gameState != _game__WEBPACK_IMPORTED_MODULE_8__.GameState.Instructions &&\n            gameState != _game__WEBPACK_IMPORTED_MODULE_8__.GameState.PreExitMessage &&\n            gameState != _game__WEBPACK_IMPORTED_MODULE_8__.GameState.PreExitCredits &&\n            gameState != _game__WEBPACK_IMPORTED_MODULE_8__.GameState.Intro1 &&\n            gameState != _game__WEBPACK_IMPORTED_MODULE_8__.GameState.Intro2 &&\n            gameState != _game__WEBPACK_IMPORTED_MODULE_8__.GameState.Intro3) {\n            this.drawScores(p0Score, p1Score, gameTime);\n        }\n        this.drawDebugView(gameConfig, futurePrediction, currentFps);\n        this.drawGamepadConnections(gameConfig, gameState, gamepadConnectSummary);\n        if (gameState == _game__WEBPACK_IMPORTED_MODULE_8__.GameState.PreExitMessage) {\n            this.drawCenteredDancingMessage(gameTime, 'They went back to the ground.', null, _color__WEBPACK_IMPORTED_MODULE_6__.Colors.white);\n        }\n        else if (gameState == _game__WEBPACK_IMPORTED_MODULE_8__.GameState.Intro1) {\n            this.drawCenteredDancingMessage(gameTime, 'They came from the ground.', null, _color__WEBPACK_IMPORTED_MODULE_6__.Colors.white);\n        }\n        else if (gameState == _game__WEBPACK_IMPORTED_MODULE_8__.GameState.Intro2) {\n            this.drawCenteredDancingMessage(gameTime, 'They brought a bouncy ball -', null, _color__WEBPACK_IMPORTED_MODULE_6__.Colors.white);\n        }\n        else if (gameState == _game__WEBPACK_IMPORTED_MODULE_8__.GameState.Intro3) {\n            this.drawCenteredDancingMessage(gameTime, '- and they bounced it around.', null, _color__WEBPACK_IMPORTED_MODULE_6__.Colors.white);\n        }\n        else if (gameState == _game__WEBPACK_IMPORTED_MODULE_8__.GameState.AutoPaused) {\n            this.drawCenteredDancingMessage(gameTime, 'Please reconnect your controller.', null, _color__WEBPACK_IMPORTED_MODULE_6__.Colors.white);\n        }\n        else if (gameState == _game__WEBPACK_IMPORTED_MODULE_8__.GameState.PreExitCredits) {\n            this.drawCenteredDancingMessage(gameTime, 'Every day is an adventure', 'tcftg.com', _color__WEBPACK_IMPORTED_MODULE_6__.Colors.white);\n        }\n    }\n    drawFlowers(gameConfig, leftTreeTopWidth, leftTreeTopHeight, rightTreeTopWidth, rightTreeTopHeight) {\n        this.spriteBatch.drawTextureCentered(this.getTexture('leftFlower'), gameConfig.leftWall.center, { w: gameConfig.leftWall.width, h: gameConfig.leftWall.height }, 0, 1);\n        this.spriteBatch.drawTextureCentered(this.getTexture('leftFlowerTop'), { x: gameConfig.leftWall.center.x + gameConfig.leftWall.width / 3, y: gameConfig.leftWall.center.y + gameConfig.leftWall.height / 2 }, { w: leftTreeTopWidth, h: leftTreeTopHeight }, 0, 1);\n        this.spriteBatch.drawTextureCentered(this.getTexture('rightFlower'), gameConfig.rightWall.center, { w: gameConfig.rightWall.width, h: gameConfig.rightWall.height }, 0, 1);\n        this.spriteBatch.drawTextureCentered(this.getTexture('rightFlowerTop'), {\n            x: gameConfig.rightWall.center.x - gameConfig.rightWall.width / 3,\n            y: gameConfig.rightWall.center.y + gameConfig.rightWall.height / 2,\n        }, { w: rightTreeTopWidth, h: rightTreeTopHeight }, 0, 1);\n    }\n    drawBall(ball, i) {\n        if (ball.isAlive) {\n            if (i % 2 == 0)\n                this.spriteBatch.drawTextureCentered(this.getTexture('ball1'), ball.physics.center, { w: ball.physics.diameter, h: ball.physics.diameter }, ball.physics.orientation, 1);\n            else\n                this.spriteBatch.drawTextureCentered(this.getTexture('ball2'), ball.physics.center, { w: ball.physics.diameter, h: ball.physics.diameter }, ball.physics.orientation, 1);\n            this.spriteBatch.drawTextureCentered(this.getTexture('ballShadow'), ball.physics.center, { w: ball.physics.diameter, h: ball.physics.diameter }, 0, 1);\n        }\n    }\n    drawGamepadConnections(gameConfig, gameState, gCS) {\n        const ignore = [_game__WEBPACK_IMPORTED_MODULE_8__.GameState.Action, _game__WEBPACK_IMPORTED_MODULE_8__.GameState.PreAction, _game__WEBPACK_IMPORTED_MODULE_8__.GameState.PointForPlayer0, _game__WEBPACK_IMPORTED_MODULE_8__.GameState.PointForPlayer1];\n        if (ignore.includes(gameState)) {\n            return;\n        }\n        // draw FPS in bottom rigth corner\n        const view = this.canvasManager.viewableRegion;\n        //const tlC = this.canvasManager.topLeftCorner()\n        //const bRC = this.canvasManager.bottomRightCorner()\n        const onePixel = this.canvasManager.onePixel;\n        const height = 100;\n        const width = 100;\n        const kbLeftOpacity = gCS.left ? 0.1 : 1;\n        const gpLeftOpacity = gCS.left ? 1 : 0.1;\n        const kbRightOpacity = gCS.right ? 0.1 : 1;\n        const gpRightOpacity = gCS.right ? 1 : 0.1;\n        const kbLeftRect = {\n            x1: view.x1 + 70 * onePixel,\n            x2: view.x1 + 70 * onePixel + onePixel * width,\n            y1: view.y1 + onePixel * height,\n            y2: view.y1 + onePixel * height * 2,\n        };\n        const gpLeftRect = {\n            x1: kbLeftRect.x2 + onePixel * 10,\n            x2: kbLeftRect.x2 + onePixel * (10 + width),\n            y1: view.y1 + onePixel * height,\n            y2: view.y1 + onePixel * height * 2,\n        };\n        this.spriteBatch.drawTextureInRect(this.getTexture('keyboard'), kbLeftRect, kbLeftOpacity);\n        this.spriteBatch.drawTextureInRect(this.getTexture('gamepad'), gpLeftRect, gpLeftOpacity);\n        // now player 2\n        const kbRightRect = {\n            x1: view.x2 - onePixel * width * 3.8 + onePixel * width,\n            x2: view.x2 - onePixel * width * 3.8 + onePixel * width * 2,\n            y1: view.y1 + onePixel * height,\n            y2: view.y1 + onePixel * height * 2,\n        };\n        const gpRightRect = {\n            x1: kbRightRect.x2 + onePixel * 10,\n            x2: kbRightRect.x2 + onePixel * (10 + width),\n            y1: view.y1 + onePixel * height,\n            y2: view.y1 + onePixel * height * 2,\n        };\n        this.spriteBatch.drawTextureInRect(this.getTexture('keyboard'), kbRightRect, kbRightOpacity);\n        this.spriteBatch.drawTextureInRect(this.getTexture('gamepad'), gpRightRect, gpRightOpacity);\n        //console.log(kbLeftRect)\n    }\n    drawDebugView(gameConfig, futurePrediction, currentFps) {\n        var _a;\n        // draw FPS in bottom rigth corner\n        const view = this.canvasManager.viewableRegion;\n        const onePixel = this.canvasManager.onePixel;\n        const height = onePixel * 36;\n        const xPos = view.x1 + height * 2;\n        const yPos = view.y1 + height * 2;\n        const color = new _color__WEBPACK_IMPORTED_MODULE_6__.Color(0, 0, 0, 0.25);\n        const font = this.font('regular');\n        this.spriteBatch.drawStringUncentered(`${~~currentFps} fps`, font, height, { x: xPos, y: yPos }, color, 0);\n        const suggAt = 90;\n        if (currentFps && currentFps < suggAt) {\n            const opacity = 0.5 * (1 - currentFps / suggAt);\n            this.spriteBatch.drawStringUncentered(`lmk if a smaller window improves smoothness/fps`, font, height * 0.75, { x: xPos, y: yPos - height * 1.1 }, new _color__WEBPACK_IMPORTED_MODULE_6__.Color(0, 0, 0, opacity), 0);\n        }\n        currentFps;\n        if (this.inDebugView) {\n            const alpha = (s) => 1 - Math.sqrt(s.time / _tweakables__WEBPACK_IMPORTED_MODULE_13__[\"default\"].predictionLookahead);\n            for (let i = 0; i < gameConfig.balls.length; i++) {\n                const prediction = futurePrediction[i];\n                for (const state of (_a = prediction.ballStates) !== null && _a !== void 0 ? _a : []) {\n                    this.spriteBatch.drawTextureCentered(this.getTexture('predictionDot'), state.pos, { w: 0.01, h: 0.01 }, 0, alpha(state));\n                }\n                for (const s of [_types__WEBPACK_IMPORTED_MODULE_14__.PlayerSide.Left, _types__WEBPACK_IMPORTED_MODULE_14__.PlayerSide.Right]) {\n                    const entrance = prediction.ballEnteringJumpRange(s);\n                    if (entrance === null || entrance === void 0 ? void 0 : entrance.isKnown)\n                        this.spriteBatch.drawTextureCentered(this.getTexture('kapowScore'), entrance.pos, { w: gameConfig.balls[i].physics.diameter, h: gameConfig.balls[i].physics.diameter }, 0, alpha(entrance));\n                }\n                const groundHit = prediction.ballHittingGround;\n                if (groundHit === null || groundHit === void 0 ? void 0 : groundHit.isKnown)\n                    this.spriteBatch.drawTextureCentered(this.getTexture('kapowScore'), prediction.ballHittingGround.pos, { w: gameConfig.balls[i].physics.diameter, h: gameConfig.balls[i].physics.diameter }, 0, alpha(groundHit));\n            }\n        }\n    }\n    drawMenuBanner(bannerTexture, gameTime, center) {\n        const seconds = gameTime.totalGameTime.totalSeconds;\n        const beat = 2.0 * Math.PI * seconds * (_tweakables__WEBPACK_IMPORTED_MODULE_13__[\"default\"].menu.bpm / 60); // 87bmp\n        const destination = center;\n        const sizeMultiplier = 0.05 + Math.sin(beat / 2) / 40 + Math.sin(beat / 8) / 40;\n        const scale = { x: sizeMultiplier, y: sizeMultiplier };\n        const rect = {\n            x1: destination.x,\n            y1: destination.y,\n            x2: destination.x + scale.x,\n            y2: destination.y + scale.y,\n        };\n        this.spriteBatch.drawTextureInRect(bannerTexture, rect, 1);\n    }\n    drawScores(p0Score, p1Score, gameTime) {\n        const seconds = gameTime.totalGameTime.totalSeconds;\n        const rotMax = 0.02;\n        const rotation = rotMax + 2 * rotMax * Math.sin(gameTime.totalGameTime.totalSeconds);\n        const scaleMax = 0.1;\n        const beat = 2.0 * Math.PI * seconds * (_tweakables__WEBPACK_IMPORTED_MODULE_13__[\"default\"].menu.bpm / 60); // 87bmp\n        const extraScale = 1 - scaleMax * Math.sin(beat / 4) - scaleMax * Math.sin(beat / 8);\n        const view = this.canvasManager.viewableRegion;\n        const scoreCardHeight = ((view.y2 - view.y1) / 10) * extraScale;\n        const y = (9 * view.y2 + view.y1) / 10; // most of the way towards tL.y\n        const x1 = (9 * view.x1 + view.x2) / 10; // most of the way to the left side\n        const x2 = (9 * view.x2 + view.x1) / 10; //  most of the way to the right side\n        const box1Center = { x: x1, y };\n        const box2Center = { x: x2, y };\n        const text1 = `${p0Score}`;\n        const p0h = this.p0ScoreCard.sizeMultiplier * scoreCardHeight;\n        this.spriteBatch.drawTextureCentered(this.getTexture('scoreCard'), box1Center, { w: p0h, h: p0h }, rotation, 1);\n        const font = this.font('extraBold');\n        this.spriteBatch.drawStringCentered(text1, font, p0h * 0.9 * this.p0ScoreCard.sizeMultiplier, box1Center, _color__WEBPACK_IMPORTED_MODULE_6__.Colors.black, rotation);\n        const text2 = `${p1Score}`;\n        const p1h = this.p1ScoreCard.sizeMultiplier * scoreCardHeight;\n        this.spriteBatch.drawTextureCentered(this.getTexture('scoreCard'), box2Center, { w: p1h, h: p1h }, rotation, 1);\n        this.spriteBatch.drawStringCentered(text2, font, p1h * 0.9 * this.p1ScoreCard.sizeMultiplier, box2Center, _color__WEBPACK_IMPORTED_MODULE_6__.Colors.black, rotation);\n    }\n    adjustZoomLevel(maxBallHeight, dt) {\n        this.canvasManager.adjustZoomLevel(maxBallHeight, dt);\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/display.ts?");

/***/ }),

/***/ "./src/font-manager.ts":
/*!*****************************!*\
  !*** ./src/font-manager.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FontManager\": () => (/* binding */ FontManager)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nconst fontsToLoad = {\n    extraBold: { family: 'Nunito Sans', weight: 600, url: '/fonts/NunitoSans/NunitoSans-ExtraBold.ttf' },\n    regular: { family: 'Nunito Sans', weight: 400, url: '/fonts/NunitoSans/NunitoSans-Regular.ttf' },\n};\nclass FontManager {\n    constructor(content) {\n        this.content = content;\n        this.fonts = new Map();\n    }\n    getFont(name) {\n        const res = this.fonts.get(name);\n        if (!res)\n            throw new Error(`Could not getFont() ${name}`);\n        return res;\n    }\n    loadOneFont(name, request) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.content.loadFont(request.family, request.url, request.weight);\n            this.fonts.set(name, request);\n        });\n    }\n    loadContent() {\n        return __awaiter(this, void 0, void 0, function* () {\n            console.log(`Starting to load fonts`);\n            const p = [];\n            const start = Date.now();\n            for (const k of Object.keys(fontsToLoad)) {\n                const fontName = k;\n                const request = fontsToLoad[fontName];\n                p.push(this.loadOneFont(fontName, request));\n            }\n            yield Promise.all(p);\n            console.log(`Fonts loaded in ${Date.now() - start}ms.`);\n            // This will throw an error in many browsers but is good for testing in Chrome/Safari:\n            //console.log(`Fonts loaded in ${Date.now() - start}ms. Now available = `)\n            //for (const f of document.fonts.entries()) {\n            //  console.log('font: ', f)\n            //}\n        });\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/font-manager.ts?");

/***/ }),

/***/ "./src/future-prediction.ts":
/*!**********************************!*\
  !*** ./src/future-prediction.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FuturePrediction\": () => (/* binding */ FuturePrediction),\n/* harmony export */   \"unknownState\": () => (/* binding */ unknownState)\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n\nconst unknownState = () => ({\n    pos: { x: Infinity, y: Infinity },\n    time: Infinity,\n    isKnown: false,\n});\nclass FuturePrediction {\n    constructor() {\n        this.ballStates = [];\n        this.ballHittingGround = unknownState();\n        this.ballCrossingNet = unknownState();\n        this.ballEnteringPlayerJumpRange = new Map();\n        this.ballEnteringPlayerJumpRange.set(_types__WEBPACK_IMPORTED_MODULE_0__.PlayerSide.Left, unknownState());\n        this.ballEnteringPlayerJumpRange.set(_types__WEBPACK_IMPORTED_MODULE_0__.PlayerSide.Right, unknownState());\n    }\n    ballEnteringJumpRange(playerSide) {\n        const res = this.ballEnteringPlayerJumpRange.get(playerSide);\n        if (!res)\n            throw new Error(`Could not check jump range for ${playerSide}`);\n        return res;\n    }\n    setBallEnteringJumpRange(playerSide, futureState) {\n        this.ballEnteringPlayerJumpRange.set(playerSide, futureState);\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/future-prediction.ts?");

/***/ }),

/***/ "./src/game-config.ts":
/*!****************************!*\
  !*** ./src/game-config.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GameConfig\": () => (/* binding */ GameConfig),\n/* harmony export */   \"PlayerConfiguration\": () => (/* binding */ PlayerConfiguration)\n/* harmony export */ });\n/* harmony import */ var _ball__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ball */ \"./src/ball.ts\");\n/* harmony import */ var _player__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./player */ \"./src/player.ts\");\n/* harmony import */ var _rectangular_obstacle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rectangular-obstacle */ \"./src/rectangular-obstacle.ts\");\n/* harmony import */ var _tweakables__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tweakables */ \"./src/tweakables.ts\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n\n\n\n\n\nclass PlayerConfiguration {\n    constructor() {\n        this.species = _player__WEBPACK_IMPORTED_MODULE_1__.PlayerSpecies.Human;\n        this.ai = null;\n        this.playerSide = _types__WEBPACK_IMPORTED_MODULE_4__.PlayerSide.Left;\n        this.controllerAssigned = false;\n    }\n}\nclass GameConfig {\n    playerConfig(playerSide) {\n        const cfg = this.playerConfigurations.get(playerSide);\n        if (!cfg)\n            throw new Error(`No config for side ${playerSide}`);\n        return cfg;\n    }\n    player(playerSide) {\n        const p = this.players.get(playerSide);\n        if (!p)\n            throw new Error(`No player for side ${playerSide}`);\n        return p;\n    }\n    setPlayer(playerSide, p) {\n        this.players.set(playerSide, p);\n    }\n    constructor() {\n        this.playerConfigurations = new Map();\n        this.playerConfigurations.set(_types__WEBPACK_IMPORTED_MODULE_4__.PlayerSide.Left, new PlayerConfiguration());\n        this.playerConfigurations.set(_types__WEBPACK_IMPORTED_MODULE_4__.PlayerSide.Right, new PlayerConfiguration());\n        this.players = new Map();\n        this.players.set(_types__WEBPACK_IMPORTED_MODULE_4__.PlayerSide.Left, new _player__WEBPACK_IMPORTED_MODULE_1__.Player(_tweakables__WEBPACK_IMPORTED_MODULE_3__[\"default\"].player.defaultSettings));\n        this.players.set(_types__WEBPACK_IMPORTED_MODULE_4__.PlayerSide.Right, new _player__WEBPACK_IMPORTED_MODULE_1__.Player(_tweakables__WEBPACK_IMPORTED_MODULE_3__[\"default\"].player.defaultSettings));\n        this.balls = [];\n        this.balls.push(new _ball__WEBPACK_IMPORTED_MODULE_0__.Ball({ x: 0.25, y: 0.5 }, // Position\n        { x: 0.0, y: 0.4 }, // Velocity\n        _tweakables__WEBPACK_IMPORTED_MODULE_3__[\"default\"].ball.defaultSettings.diameter, _tweakables__WEBPACK_IMPORTED_MODULE_3__[\"default\"].ball.defaultSettings.mass, _tweakables__WEBPACK_IMPORTED_MODULE_3__[\"default\"].ball.defaultSettings.maxSpeed, 0.0, // Orientation\n        0.0, // Rotation Speed\n        true));\n        this.balls.push(new _ball__WEBPACK_IMPORTED_MODULE_0__.Ball({ x: 0.75, y: 0.5 }, // Position\n        { x: 0.0, y: 0.4 }, // Velocity\n        _tweakables__WEBPACK_IMPORTED_MODULE_3__[\"default\"].ball.defaultSettings.diameter, _tweakables__WEBPACK_IMPORTED_MODULE_3__[\"default\"].ball.defaultSettings.mass, _tweakables__WEBPACK_IMPORTED_MODULE_3__[\"default\"].ball.defaultSettings.maxSpeed, 0.0, // Orientation\n        0.0, // Rotation Speed\n        true));\n        this.net = new _rectangular_obstacle__WEBPACK_IMPORTED_MODULE_2__.RectangularObstacle(_tweakables__WEBPACK_IMPORTED_MODULE_3__[\"default\"].net.center, _tweakables__WEBPACK_IMPORTED_MODULE_3__[\"default\"].net.width, _tweakables__WEBPACK_IMPORTED_MODULE_3__[\"default\"].net.height);\n        this.leftWall = new _rectangular_obstacle__WEBPACK_IMPORTED_MODULE_2__.RectangularObstacle(_tweakables__WEBPACK_IMPORTED_MODULE_3__[\"default\"].leftWall.center, _tweakables__WEBPACK_IMPORTED_MODULE_3__[\"default\"].leftWall.width, _tweakables__WEBPACK_IMPORTED_MODULE_3__[\"default\"].leftWall.height);\n        this.rightWall = new _rectangular_obstacle__WEBPACK_IMPORTED_MODULE_2__.RectangularObstacle(_tweakables__WEBPACK_IMPORTED_MODULE_3__[\"default\"].rightWall.center, _tweakables__WEBPACK_IMPORTED_MODULE_3__[\"default\"].rightWall.width, _tweakables__WEBPACK_IMPORTED_MODULE_3__[\"default\"].rightWall.height);\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/game-config.ts?");

/***/ }),

/***/ "./src/game.ts":
/*!*********************!*\
  !*** ./src/game.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Game\": () => (/* binding */ Game),\n/* harmony export */   \"GameState\": () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_17__.GameState)\n/* harmony export */ });\n/* harmony import */ var _ai_black_ai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ai/black-ai */ \"./src/ai/black-ai.ts\");\n/* harmony import */ var _ai_green_ai__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ai/green-ai */ \"./src/ai/green-ai.ts\");\n/* harmony import */ var _ai_purple_ai__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ai/purple-ai */ \"./src/ai/purple-ai.ts\");\n/* harmony import */ var _ai_white_ai__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ai/white-ai */ \"./src/ai/white-ai.ts\");\n/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./color */ \"./src/color.ts\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constants */ \"./src/constants.ts\");\n/* harmony import */ var _content_loader__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./content-loader */ \"./src/content-loader.ts\");\n/* harmony import */ var _display__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./display */ \"./src/display.ts\");\n/* harmony import */ var _future_prediction__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./future-prediction */ \"./src/future-prediction.ts\");\n/* harmony import */ var _game_config__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./game-config */ \"./src/game-config.ts\");\n/* harmony import */ var _history_manager__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./history-manager */ \"./src/history-manager.ts\");\n/* harmony import */ var _input__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./input */ \"./src/input.ts\");\n/* harmony import */ var _kapow_manager__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./kapow-manager */ \"./src/kapow-manager.ts\");\n/* harmony import */ var _menu__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./menu */ \"./src/menu.ts\");\n/* harmony import */ var _player__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./player */ \"./src/player.ts\");\n/* harmony import */ var _sound_manager__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./sound-manager */ \"./src/sound-manager.ts\");\n/* harmony import */ var _tweakables__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./tweakables */ \"./src/tweakables.ts\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass Game {\n    constructor(targetDiv, contentLoadMonitor) {\n        this.scoreLeftPlayer = 0;\n        this.scoreRightPlayer = 0;\n        this.whoseServe = _types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left;\n        this.gameState = _types__WEBPACK_IMPORTED_MODULE_17__.GameState.PreStart;\n        this.futurePredictionList = [];\n        this.isContentLoadedYet = false;\n        this.accumulatedGamePlayTime = 0; // How much the clock has run this game, in ms, excluding pauses and between points\n        this.accumulatedStateTime = 0; // Time accumulated since last gamestate change\n        this.accumulatedPointTime = 0; // Accumulated play time this point (persists even if pausing it to go to menu)\n        this.whenStartedDateTime = Date.now();\n        this.content = new _content_loader__WEBPACK_IMPORTED_MODULE_6__.ContentLoader(contentLoadMonitor);\n        this.gameConfig = new _game_config__WEBPACK_IMPORTED_MODULE_9__.GameConfig();\n        this.kapowManager = new _kapow_manager__WEBPACK_IMPORTED_MODULE_12__.KapowManager();\n        this.historyManager = new _history_manager__WEBPACK_IMPORTED_MODULE_10__.HistoryManager();\n        this.lastFuturePrediction = 0;\n        this.fpsTimer = [];\n        this.isGamePoint = false;\n        this.currentGameTime = this.emptyGameTime();\n        this.resetScores();\n        this.init(targetDiv);\n    }\n    init(targetDiv) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.sound = new _sound_manager__WEBPACK_IMPORTED_MODULE_15__.SoundManager(this.content);\n            this.display = new _display__WEBPACK_IMPORTED_MODULE_7__.Display(this.content, targetDiv);\n            this.menu = new _menu__WEBPACK_IMPORTED_MODULE_13__.Menu(this.display);\n            this.input = new _input__WEBPACK_IMPORTED_MODULE_11__.Input(this.gameConfig);\n            yield this.loadContent();\n            this.resetScores();\n            this.resetPlayers();\n            this.playerLeftCfg.species = _player__WEBPACK_IMPORTED_MODULE_14__.PlayerSpecies.Human;\n            this.playerRightCfg.species = _player__WEBPACK_IMPORTED_MODULE_14__.PlayerSpecies.Human;\n            this.setGameState(_types__WEBPACK_IMPORTED_MODULE_17__.GameState.PreStart);\n            this.futurePredictionList = [];\n            for (let i = 0; i < this.gameConfig.balls.length; i++) {\n                this.futurePredictionList.push(new _future_prediction__WEBPACK_IMPORTED_MODULE_8__.FuturePrediction());\n            }\n        });\n    }\n    get playerLeft() {\n        return this.gameConfig.player(_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left);\n    }\n    get playerRight() {\n        return this.gameConfig.player(_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Right);\n    }\n    get playerLeftCfg() {\n        return this.gameConfig.playerConfig(_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left);\n    }\n    get playerRightCfg() {\n        return this.gameConfig.playerConfig(_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Right);\n    }\n    emptyGameTime() {\n        return {\n            totalGameTime: {\n                totalMilliseconds: 0,\n                totalSeconds: 0,\n            },\n            elapsedGameTime: {\n                totalMilliseconds: 0,\n                totalSeconds: 0,\n            },\n        };\n    }\n    resetPlayers() {\n        const pLeftConfig = {\n            maxVel: { x: 0.8, y: 1.2 },\n            diameter: 0.15,\n            mass: 3,\n            xSpringConstant: 30,\n            gravityMultiplier: 1.9,\n            targetXVel: 0,\n        };\n        const pRightConfig = {\n            maxVel: { x: 0.8, y: 1.2 },\n            diameter: 0.15,\n            mass: 3,\n            xSpringConstant: 30,\n            gravityMultiplier: 1.9,\n            targetXVel: 0,\n        };\n        this.gameConfig.setPlayer(_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left, new _player__WEBPACK_IMPORTED_MODULE_14__.Player(pLeftConfig));\n        this.gameConfig.setPlayer(_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Right, new _player__WEBPACK_IMPORTED_MODULE_14__.Player(pRightConfig));\n    }\n    run() {\n        return __awaiter(this, void 0, void 0, function* () {\n            while (!this.isContentLoadedYet) {\n                yield (0,_utils__WEBPACK_IMPORTED_MODULE_18__.timeout)(100);\n            }\n            this.whenStartedDateTime = Date.now();\n            this.display.initialDraw();\n            yield this.runLoop();\n        });\n    }\n    updateFps() {\n        this.fpsTimer.push(Date.now());\n        if (this.fpsTimer.length > _tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].fpsSampleCount) {\n            this.fpsTimer.splice(0, 1);\n        }\n    }\n    getCurrentFps() {\n        const len = this.fpsTimer.length;\n        return len <= 1 ? 0 : 1000 / ((this.fpsTimer[len - 1] - this.fpsTimer[0]) / len);\n    }\n    runLoop() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const startTime = Date.now();\n            let lastTime = Date.now();\n            while (this.gameState !== _types__WEBPACK_IMPORTED_MODULE_17__.GameState.Exit) {\n                this.input.updateInputStates();\n                this.updateFps();\n                yield (0,_utils__WEBPACK_IMPORTED_MODULE_18__.timeout)(_constants__WEBPACK_IMPORTED_MODULE_5__[\"default\"].gameLoopDelayMs);\n                const currTime = Date.now();\n                const dt = currTime - lastTime;\n                this.currentGameTime = {\n                    totalGameTime: {\n                        totalMilliseconds: currTime - startTime,\n                        totalSeconds: (currTime - startTime) / 1000,\n                    },\n                    elapsedGameTime: {\n                        totalMilliseconds: dt,\n                        totalSeconds: dt / 1000,\n                    },\n                };\n                this.update(this.currentGameTime);\n                this.draw(this.currentGameTime);\n                lastTime = currTime;\n            }\n        });\n    }\n    setGameState(gs) {\n        if (gs !== _types__WEBPACK_IMPORTED_MODULE_17__.GameState.PreStart) {\n            // hello world\n        }\n        if (gs !== this.gameState)\n            this.accumulatedStateTime = 0.0;\n        this.gameState = gs;\n        if (gs === _types__WEBPACK_IMPORTED_MODULE_17__.GameState.PreAction || gs === _types__WEBPACK_IMPORTED_MODULE_17__.GameState.Intro1)\n            this.setUpForServe();\n        if (gs === _types__WEBPACK_IMPORTED_MODULE_17__.GameState.MainMenu ||\n            gs === _types__WEBPACK_IMPORTED_MODULE_17__.GameState.Paused ||\n            gs === _types__WEBPACK_IMPORTED_MODULE_17__.GameState.Instructions ||\n            gs === _types__WEBPACK_IMPORTED_MODULE_17__.GameState.PreExitMessage ||\n            gs === _types__WEBPACK_IMPORTED_MODULE_17__.GameState.PreExitCredits ||\n            gs === _types__WEBPACK_IMPORTED_MODULE_17__.GameState.Intro1 ||\n            gs === _types__WEBPACK_IMPORTED_MODULE_17__.GameState.Intro2 ||\n            gs === _types__WEBPACK_IMPORTED_MODULE_17__.GameState.Intro3 ||\n            gs === _types__WEBPACK_IMPORTED_MODULE_17__.GameState.VictoryForPlayer0 ||\n            gs === _types__WEBPACK_IMPORTED_MODULE_17__.GameState.VictoryForPlayer1) {\n            this.sound.playIfNotPlaying('themeSong', 1.0, 0.0, 0.0, true);\n        }\n        else if (gs !== _types__WEBPACK_IMPORTED_MODULE_17__.GameState.PreStart) {\n            this.sound.stopThemeMusic();\n        }\n        if (gs === _types__WEBPACK_IMPORTED_MODULE_17__.GameState.Action && !this.isGamePoint) {\n            this.sound.playIfNotPlaying('gamePlayMusic', 0.5, 0.0, 0.0, true);\n        }\n        else if (gs === _types__WEBPACK_IMPORTED_MODULE_17__.GameState.Paused || gs === _types__WEBPACK_IMPORTED_MODULE_17__.GameState.AutoPaused) {\n            this.sound.stopPlayMusic();\n        }\n    }\n    loadContent() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const contentStartTime = Date.now();\n            console.log(`Starting to load content`);\n            yield Promise.all([this.sound.loadContent(), this.display.loadContent()]);\n            console.log(`Finished loading content ${Date.now() - contentStartTime}ms`);\n            this.isContentLoadedYet = true;\n        });\n    }\n    getPlayerName(playerSide) {\n        if (playerSide === _types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left)\n            return 'Red';\n        const c = this.gameConfig.playerConfig(playerSide);\n        if (c.species === _player__WEBPACK_IMPORTED_MODULE_14__.PlayerSpecies.Human)\n            return 'Blue';\n        else if (c.ai instanceof _ai_green_ai__WEBPACK_IMPORTED_MODULE_1__.GreenAi)\n            return 'Green';\n        else if (c.ai instanceof _ai_white_ai__WEBPACK_IMPORTED_MODULE_3__.WhiteAi)\n            return 'White';\n        else if (c.ai instanceof _ai_black_ai__WEBPACK_IMPORTED_MODULE_0__.BlackAi)\n            return 'Black';\n        else\n            return 'Purple';\n    }\n    draw(gameTime) {\n        const dt = gameTime.elapsedGameTime.totalSeconds;\n        this.kapowManager.step(dt);\n        this.display.draw(gameTime, this.gameState, this.gameConfig, this.scoreLeftPlayer, this.scoreRightPlayer, this.futurePredictionList, this.kapowManager, this.getCurrentFps(), this.input.gamepadConnectSummary());\n        if (this.gameState === _types__WEBPACK_IMPORTED_MODULE_17__.GameState.VictoryForPlayer0 || this.gameState === _types__WEBPACK_IMPORTED_MODULE_17__.GameState.VictoryForPlayer1) {\n            this.isGamePoint = false;\n            const minutes = Math.floor(this.accumulatedGamePlayTime / 60.0);\n            const seconds = Math.floor(this.accumulatedGamePlayTime - minutes * 60);\n            const time = minutes > 0 ? `${minutes} min ${seconds} sec` : `${seconds} seconds`;\n            if (this.scoreLeftPlayer === 0 || this.scoreRightPlayer === 0)\n                this.display.drawCenteredDancingMessage(gameTime, 'Shutout!', 'Victory in ' + time + '.', _color__WEBPACK_IMPORTED_MODULE_4__.Colors.white);\n            else if (this.gameState === _types__WEBPACK_IMPORTED_MODULE_17__.GameState.VictoryForPlayer0)\n                this.display.drawCenteredDancingMessage(gameTime, this.getPlayerName(_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left) + ' Wins!', ' Victory in ' + time + '.', _color__WEBPACK_IMPORTED_MODULE_4__.Colors.white);\n            else if (this.gameState === _types__WEBPACK_IMPORTED_MODULE_17__.GameState.VictoryForPlayer1)\n                this.display.drawCenteredDancingMessage(gameTime, this.getPlayerName(_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Right) + ' Wins!', ' Victory in ' + time + '.', _color__WEBPACK_IMPORTED_MODULE_4__.Colors.white);\n        }\n        if (this.gameState === _types__WEBPACK_IMPORTED_MODULE_17__.GameState.PointForPlayer0) {\n        }\n        else if (this.gameState === _types__WEBPACK_IMPORTED_MODULE_17__.GameState.PointForPlayer1) {\n        }\n        else if (this.gameState === _types__WEBPACK_IMPORTED_MODULE_17__.GameState.Paused) {\n            this.menu.draw(true, gameTime);\n        }\n        else if (this.gameState === _types__WEBPACK_IMPORTED_MODULE_17__.GameState.MainMenu) {\n            this.menu.draw(false, gameTime);\n        }\n        else if (this.gameState === _types__WEBPACK_IMPORTED_MODULE_17__.GameState.Instructions)\n            this.display.drawControllerInstructions();\n        else if (this.gameState === _types__WEBPACK_IMPORTED_MODULE_17__.GameState.PreExitCredits)\n            this.display.drawCredits(gameTime);\n    }\n    startNewTwoPlayerGame(numBalls) {\n        this.resetScores();\n        this.resetPlayers();\n        this.whoseServe = Math.random() < 0.5 ? _types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left : _types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Right;\n        this.setGameState(_types__WEBPACK_IMPORTED_MODULE_17__.GameState.PreAction);\n        this.gameConfig.playerConfig(_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left).species = _player__WEBPACK_IMPORTED_MODULE_14__.PlayerSpecies.Human;\n        this.gameConfig.playerConfig(_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Right).species = _player__WEBPACK_IMPORTED_MODULE_14__.PlayerSpecies.Human;\n        this.accumulatedGamePlayTime = 0.0;\n        this.gameConfig.balls[1].isAlive = numBalls === 2;\n        this.display.atmosphere.makeItSunny();\n    }\n    startNewHumanAgainstAIGame(ai, gamepadSide) {\n        console.log(`new game by...`, this.menu.getWhoOwnsMenu());\n        if (gamepadSide === _types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Right) {\n            this.input.swapGamepadSides();\n        }\n        this.resetScores();\n        this.resetPlayers();\n        this.whoseServe = _types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left;\n        this.setGameState(_types__WEBPACK_IMPORTED_MODULE_17__.GameState.PreAction);\n        this.gameConfig.playerConfig(_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left).species = _player__WEBPACK_IMPORTED_MODULE_14__.PlayerSpecies.Human;\n        this.gameConfig.playerConfig(_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Right).species = _player__WEBPACK_IMPORTED_MODULE_14__.PlayerSpecies.Ai;\n        this.gameConfig.playerConfig(_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Right).ai = ai;\n        this.accumulatedGamePlayTime = 0.0;\n        if (ai instanceof _ai_green_ai__WEBPACK_IMPORTED_MODULE_1__.GreenAi || ai instanceof _ai_black_ai__WEBPACK_IMPORTED_MODULE_0__.BlackAi) {\n            this.gameConfig.balls[1].isAlive = false;\n        }\n        else {\n            this.gameConfig.balls[1].isAlive = true;\n        }\n        this.display.atmosphere.makeItSunny();\n    }\n    handleInstructionsInputs() {\n        for (let i = 1; i <= 4; i++) {\n            if (this.input.wasMenuSelectJustPushed(null).selected) {\n                if (this.scoreLeftPlayer !== 0 || this.scoreRightPlayer !== 0)\n                    this.setGameState(_types__WEBPACK_IMPORTED_MODULE_17__.GameState.Paused);\n                else\n                    this.setGameState(_types__WEBPACK_IMPORTED_MODULE_17__.GameState.MainMenu);\n            }\n        }\n    }\n    handlePreExitInputs() {\n        let stepForward = false;\n        for (let i = 1; i <= 4; i++) {\n            if (this.input.wasMenuSelectJustPushed(null).selected) {\n                stepForward = true;\n            }\n        }\n        if (stepForward && this.gameState === _types__WEBPACK_IMPORTED_MODULE_17__.GameState.PreExitCredits)\n            this.setGameState(_types__WEBPACK_IMPORTED_MODULE_17__.GameState.Exit);\n        else if (stepForward)\n            this.setGameState(_types__WEBPACK_IMPORTED_MODULE_17__.GameState.PreExitCredits);\n    }\n    handleIntroInputs() {\n        let stepForward = false;\n        for (let i = 1; i <= 4; i++) {\n            if (this.input.wasMenuSelectJustPushed(null).selected) {\n                if (Date.now() - this.whenStartedDateTime > 250) {\n                    stepForward = true;\n                }\n            }\n        }\n        if (stepForward && this.gameState === _types__WEBPACK_IMPORTED_MODULE_17__.GameState.Intro1)\n            this.setGameState(_types__WEBPACK_IMPORTED_MODULE_17__.GameState.Intro2);\n        else if (stepForward && this.gameState === _types__WEBPACK_IMPORTED_MODULE_17__.GameState.Intro2)\n            this.setGameState(_types__WEBPACK_IMPORTED_MODULE_17__.GameState.Intro3);\n        else if (stepForward)\n            this.setGameState(_types__WEBPACK_IMPORTED_MODULE_17__.GameState.MainMenu);\n    }\n    handleAutoPausedInputs() {\n        // Exit this state if controller reconnected\n        if (this.input.doesPlayerHaveGamepad(_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left) &&\n            (this.gameConfig.playerConfig(_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Right).species !== _player__WEBPACK_IMPORTED_MODULE_14__.PlayerSpecies.Human || this.input.doesPlayerHaveGamepad(_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Right))) {\n            // Remove menu ownership\n            this.menu.setWhoOwnsMenu(null);\n            // Go to paused menu\n            this.setGameState(_types__WEBPACK_IMPORTED_MODULE_17__.GameState.Paused);\n            // Select \"return to game\"\n            this.menu.select(0, _types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left);\n        }\n    }\n    handleMenuInputs() {\n        const owner = this.menu.getWhoOwnsMenu();\n        const menuSelectResult = this.input.wasMenuSelectJustPushed(owner);\n        if (this.input.wasMenuDownJustPushed(owner))\n            this.menu.moveDown(owner);\n        else if (this.input.wasMenuUpJustPushed(owner))\n            this.menu.moveUp(owner);\n        if (menuSelectResult.selected) {\n            const gamepadSide = menuSelectResult.byPlayerSide;\n            const action = this.menu.returnSelection();\n            if (action === _menu__WEBPACK_IMPORTED_MODULE_13__.MenuOptions.Play2Player1Ball) {\n                this.startNewTwoPlayerGame(1);\n            }\n            if (action === _menu__WEBPACK_IMPORTED_MODULE_13__.MenuOptions.Play2Player2Balls) {\n                this.startNewTwoPlayerGame(2);\n            }\n            else if (action === _menu__WEBPACK_IMPORTED_MODULE_13__.MenuOptions.PlayGreen) {\n                this.startNewHumanAgainstAIGame(new _ai_green_ai__WEBPACK_IMPORTED_MODULE_1__.GreenAi(), gamepadSide);\n            }\n            else if (action === _menu__WEBPACK_IMPORTED_MODULE_13__.MenuOptions.PlayPurple) {\n                this.startNewHumanAgainstAIGame(new _ai_purple_ai__WEBPACK_IMPORTED_MODULE_2__.PurpleAi(), gamepadSide);\n            }\n            else if (action === _menu__WEBPACK_IMPORTED_MODULE_13__.MenuOptions.PlayBlack) {\n                this.startNewHumanAgainstAIGame(new _ai_black_ai__WEBPACK_IMPORTED_MODULE_0__.BlackAi(), gamepadSide);\n            }\n            else if (action === _menu__WEBPACK_IMPORTED_MODULE_13__.MenuOptions.PlayWhite) {\n                this.startNewHumanAgainstAIGame(new _ai_white_ai__WEBPACK_IMPORTED_MODULE_3__.WhiteAi(), gamepadSide);\n            }\n            else if (action === _menu__WEBPACK_IMPORTED_MODULE_13__.MenuOptions.Exit)\n                this.setGameState(_types__WEBPACK_IMPORTED_MODULE_17__.GameState.PreExitMessage);\n            else if (action === _menu__WEBPACK_IMPORTED_MODULE_13__.MenuOptions.Instructions)\n                this.setGameState(_types__WEBPACK_IMPORTED_MODULE_17__.GameState.Instructions);\n            else if (action === _menu__WEBPACK_IMPORTED_MODULE_13__.MenuOptions.ReturnToGame)\n                this.setGameState(_types__WEBPACK_IMPORTED_MODULE_17__.GameState.Action);\n        }\n        // Pressing B or Start from Pause returns to Game\n        if (this.gameState === _types__WEBPACK_IMPORTED_MODULE_17__.GameState.Paused) {\n            if (this.input.wasMenuExitJustPushed(owner))\n                this.setGameState(_types__WEBPACK_IMPORTED_MODULE_17__.GameState.Action);\n        }\n    }\n    handleVictoryInputs() {\n        if (this.accumulatedStateTime > 1.0 && this.input.wasPostgameProceedJustPushed()) {\n            this.setGameState(_types__WEBPACK_IMPORTED_MODULE_17__.GameState.MainMenu);\n        }\n    }\n    handlePointInputs() {\n        if (this.accumulatedStateTime > _tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].timeAfterPointToReturnHome) {\n            let allBallsReset = true;\n            for (const ball of this.gameConfig.balls) {\n                if (ball.isAlive && ball.physics.center.y > 0.0 + ball.physics.diameter / 2) {\n                    allBallsReset = false;\n                }\n            }\n            if (allBallsReset) {\n                this.setGameState(_types__WEBPACK_IMPORTED_MODULE_17__.GameState.PreAction);\n            }\n        }\n    }\n    handlePreActionInputs() {\n        if (this.accumulatedStateTime > 1.0) {\n            this.setGameState(_types__WEBPACK_IMPORTED_MODULE_17__.GameState.Action);\n        }\n    }\n    pauseTheGame(playerSide) {\n        this.menu.setWhoOwnsMenu(playerSide);\n        this.setGameState(_types__WEBPACK_IMPORTED_MODULE_17__.GameState.Paused);\n        this.menu.select(0, playerSide);\n    }\n    handleActionInputs(dt) {\n        this.handleActionInputsForPlayer(dt, _types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left);\n        this.handleActionInputsForPlayer(dt, _types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Right);\n        // AUTO-PAUSING\n        if (this.input.wasPlayerJustDisconnectedFromGamepad(_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left)) {\n            this.setGameState(_types__WEBPACK_IMPORTED_MODULE_17__.GameState.AutoPaused);\n        }\n        else if (this.gameConfig.playerConfig(_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Right).species === _player__WEBPACK_IMPORTED_MODULE_14__.PlayerSpecies.Human &&\n            this.input.wasPlayerJustDisconnectedFromGamepad(_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Right)) {\n            this.setGameState(_types__WEBPACK_IMPORTED_MODULE_17__.GameState.AutoPaused);\n        }\n        // REGULAR PAUSING\n        if (this.input.wasKeyboardPauseHit()) {\n            this.pauseTheGame(null);\n        }\n        else {\n            const padCheckPlayerSide = this.input.checkGamepadPauseHit();\n            if (padCheckPlayerSide !== null) {\n                this.pauseTheGame(padCheckPlayerSide);\n            }\n        }\n    }\n    handleActionInputsForPlayer(dt, playerSide) {\n        let player;\n        let opponent;\n        if (playerSide === _types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left) {\n            player = this.gameConfig.player(_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left);\n            opponent = this.gameConfig.player(_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Right);\n        }\n        else {\n            player = this.gameConfig.player(_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Right);\n            opponent = this.gameConfig.player(_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left);\n        }\n        const playerConfig = this.gameConfig.playerConfig(playerSide);\n        if (playerConfig.species === _player__WEBPACK_IMPORTED_MODULE_14__.PlayerSpecies.Human) {\n            player.targetXVel = 0;\n            // the following is -1...1 and maps to 0 if near the center, as determined\n            // in tweakables.thumbstickCenterTolerance\n            const thumbstickPos = this.input.getLeftThumbStickX(playerSide);\n            if (this.input.isLeftPressed(playerSide))\n                player.moveLeft();\n            else if (this.input.isRightPressed(playerSide))\n                player.moveRight();\n            else if (thumbstickPos)\n                player.moveRationally(thumbstickPos);\n            if (this.canPlayerJump(player, opponent) && this.input.isJumpPressed(playerSide))\n                player.jump();\n            // triggers only register over some threshold as dtermined in tweakables.triggerTolerance\n            const lTrigger = this.input.getTrigger(playerSide, 'left');\n            const rTrigger = this.input.getTrigger(playerSide, 'right');\n            const triggerDiff = rTrigger - lTrigger;\n            if (triggerDiff) {\n                player.grow(dt, triggerDiff * _tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].triggerGrowthMult);\n                this.sound.playGrowthNoise(playerSide, triggerDiff);\n            }\n            else if (this.input.isShrinkPressed(playerSide)) {\n                player.grow(dt, -_tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].keyboardGrowthRate);\n                this.sound.playGrowthNoise(playerSide, -_tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].keyboardGrowthRate);\n            }\n            else if (this.input.isGrowPressed(playerSide)) {\n                player.grow(dt, _tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].keyboardGrowthRate);\n                this.sound.playGrowthNoise(playerSide, _tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].keyboardGrowthRate);\n            }\n            else {\n                this.sound.fadeGrowthNoise(playerSide, dt);\n            }\n        }\n    }\n    canPlayerJump(player, opponent) {\n        if (this.accumulatedStateTime < _tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].ballPlayerLaunchTime)\n            return false;\n        else if (player.physics.vel.y > player.maxVel.y / 2)\n            return false;\n        else if (player.isOnHeight(0.0))\n            return true;\n        else if (player.isOnRectangle(this.gameConfig.net))\n            return true;\n        else if (player.isOnPlayer(opponent))\n            return true;\n        else\n            return false;\n    }\n    aIStep() {\n        var _a;\n        for (const playerSide of [_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left, _types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Right]) {\n            const config = this.gameConfig.playerConfig(playerSide);\n            if (config.species === _player__WEBPACK_IMPORTED_MODULE_14__.PlayerSpecies.Ai) {\n                const aiThinkArg = {\n                    gameTime: this.currentGameTime,\n                    accumulatedPointTime: this.accumulatedPointTime,\n                    gameConfig: this.gameConfig,\n                    myPlayerSide: playerSide,\n                    balls: this.gameConfig.balls,\n                    ballPredictions: this.futurePredictionList,\n                    gameGravity: _tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].gameGravity,\n                    p0Score: this.scoreLeftPlayer,\n                    p1Score: this.scoreRightPlayer,\n                    me: playerSide === _types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left ? this.playerLeft : this.playerRight,\n                    opponent: playerSide === _types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left ? this.playerRight : this.playerLeft,\n                };\n                (_a = config.ai) === null || _a === void 0 ? void 0 : _a.think(aiThinkArg);\n            }\n        }\n    }\n    setUpForServe() {\n        this.accumulatedPointTime = 0.0;\n        const playerL = this.gameConfig.player(_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left);\n        const playerR = this.gameConfig.player(_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Right);\n        playerL.physics.center = { x: 0.25, y: -playerL.physics.diameter / 2 - this.gameConfig.balls[0].physics.diameter };\n        playerL.physics.vel = { x: 0, y: 0 };\n        playerL.physics.vel.y = this.gameConfig.balls[0].maxSpeed;\n        playerL.targetXVel = 0.0;\n        playerR.physics.center = { x: 0.75, y: -playerR.physics.diameter / 2 - this.gameConfig.balls[1].physics.diameter };\n        playerR.physics.vel = { x: 0, y: 0 };\n        playerR.physics.vel.y = this.gameConfig.balls[0].maxSpeed;\n        playerR.targetXVel = 0.0;\n        this.gameConfig.net.center.x = 0.5;\n        this.gameConfig.balls[0].physics.center = {\n            x: this.whoseServe === _types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left ? 0.25 : 0.75,\n            y: -this.gameConfig.balls[0].physics.diameter / 2,\n        };\n        this.gameConfig.balls[0].physics.vel = { x: 0, y: this.gameConfig.balls[0].maxSpeed };\n        this.gameConfig.balls[1].physics.center = {\n            x: this.whoseServe === _types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left ? 0.75 : 0.25,\n            y: -this.gameConfig.balls[1].physics.diameter / 2,\n        };\n        this.gameConfig.balls[1].physics.vel = { x: 0, y: this.gameConfig.balls[1].maxSpeed };\n    }\n    resetScores() {\n        this.scoreLeftPlayer = 0;\n        this.scoreRightPlayer = 0;\n    }\n    checkForAndScorePoint() {\n        let pointForPlayer0 = false;\n        let pointForPlayer1 = false;\n        const ball0 = this.gameConfig.balls[0];\n        const ball1 = this.gameConfig.balls[1];\n        if (ball0.isAlive &&\n            this.accumulatedPointTime > _tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].ballPlayerLaunchTime &&\n            ball0.physics.center.y - ball0.physics.diameter / 2 <= 0.0 &&\n            ball0.physics.center.x > this.gameConfig.net.center.x) {\n            pointForPlayer0 = true;\n            this.kapowManager.addAKapow(_kapow_manager__WEBPACK_IMPORTED_MODULE_12__.KapowType.Score, ball0.physics.center, Math.random() / 10, 0.4, 0.5);\n            this.sound.play('pointScored', 0.8, 0.0, -1.0 + 2 * ball0.physics.center.x);\n        }\n        else if (ball0.isAlive &&\n            this.accumulatedPointTime > _tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].ballPlayerLaunchTime &&\n            ball0.physics.center.y - ball0.physics.diameter / 2 <= 0.0 &&\n            ball0.physics.center.x < this.gameConfig.net.center.x) {\n            pointForPlayer1 = true;\n            this.kapowManager.addAKapow(_kapow_manager__WEBPACK_IMPORTED_MODULE_12__.KapowType.Score, ball0.physics.center, Math.random() / 10, 0.4, 0.5);\n            this.sound.play('pointScored', 0.8, 0.0, -1.0 + 2 * ball0.physics.center.x);\n        }\n        if (ball1.isAlive &&\n            this.accumulatedPointTime > _tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].ballPlayerLaunchTime &&\n            ball1.physics.center.y - ball1.physics.diameter / 2 <= 0.0 &&\n            ball1.physics.center.x > this.gameConfig.net.center.x) {\n            pointForPlayer0 = true;\n            this.kapowManager.addAKapow(_kapow_manager__WEBPACK_IMPORTED_MODULE_12__.KapowType.Score, ball1.physics.center, Math.random() / 10, 0.4, 0.5);\n            this.sound.play('pointScored', 0.8, 0.0, -1.0 + 2 * ball1.physics.center.x);\n        }\n        else if (ball1.isAlive &&\n            this.accumulatedPointTime > _tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].ballPlayerLaunchTime &&\n            ball1.physics.center.y - ball1.physics.diameter / 2 <= 0.0 &&\n            ball1.physics.center.x < this.gameConfig.net.center.x) {\n            pointForPlayer1 = true;\n            this.kapowManager.addAKapow(_kapow_manager__WEBPACK_IMPORTED_MODULE_12__.KapowType.Score, ball1.physics.center, Math.random() / 10, 0.4, 0.5);\n            this.sound.play('pointScored', 0.8, 0.0, -1.0 + 2 * ball1.physics.center.x);\n        }\n        if (pointForPlayer0) {\n            this.handlePointScored(_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left);\n        }\n        else if (pointForPlayer1) {\n            this.handlePointScored(_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Right);\n        }\n        if ((this.gameState === _types__WEBPACK_IMPORTED_MODULE_17__.GameState.PointForPlayer0 || this.gameState === _types__WEBPACK_IMPORTED_MODULE_17__.GameState.PointForPlayer1) &&\n            this.scoreLeftPlayer !== this.scoreRightPlayer &&\n            (this.scoreLeftPlayer >= _tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].winningScore - 1 || this.scoreRightPlayer >= _tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].winningScore - 1)) {\n            this.sound.stopPlayMusic();\n            this.isGamePoint = true;\n            this.sound.playIfNotPlaying('gamePoint', 0.6, 0.0, 0.0, false);\n            this.display.atmosphere.makeItDark();\n        }\n        else if (pointForPlayer0 || pointForPlayer1) {\n            this.display.atmosphere.makeItSunny();\n        }\n        return pointForPlayer0 || pointForPlayer1;\n    }\n    handlePointScored(playerSide) {\n        const winByTwo = _tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].winByTwo;\n        const winScore = _tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].winningScore;\n        if (playerSide === _types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left) {\n            this.setGameState(_types__WEBPACK_IMPORTED_MODULE_17__.GameState.PointForPlayer0);\n            this.display.bounceScoreCard(playerSide);\n            this.scoreLeftPlayer++;\n            if ((this.scoreLeftPlayer >= winScore && !winByTwo) ||\n                (this.scoreLeftPlayer >= winScore && winByTwo && this.scoreLeftPlayer - this.scoreRightPlayer >= 2))\n                this.setGameState(_types__WEBPACK_IMPORTED_MODULE_17__.GameState.VictoryForPlayer0);\n            this.whoseServe = _types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left;\n        }\n        else {\n            this.setGameState(_types__WEBPACK_IMPORTED_MODULE_17__.GameState.PointForPlayer1);\n            this.display.bounceScoreCard(playerSide);\n            this.scoreRightPlayer++;\n            if ((this.scoreRightPlayer >= winScore && !winByTwo) ||\n                (this.scoreRightPlayer >= winScore && winByTwo && this.scoreRightPlayer - this.scoreLeftPlayer >= 2))\n                this.setGameState(_types__WEBPACK_IMPORTED_MODULE_17__.GameState.VictoryForPlayer1);\n            this.whoseServe = _types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Right;\n        }\n    }\n    //\n    // Keeps players constrained by floor and walls\n    //\n    constrainPlayers() {\n        for (const playerSide of [_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left, _types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Right]) {\n            const p = this.gameConfig.player(playerSide);\n            // Constrain Player to Floor. In the first second of the game they float up from it. After that they stick above it.\n            if (this.accumulatedPointTime > _tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].ballPlayerLaunchTime && p.physics.center.y < 0.0) {\n                p.physics.center.y = 0.0;\n                if (this.gameState === _types__WEBPACK_IMPORTED_MODULE_17__.GameState.Action && p.physics.vel.y < 0)\n                    p.physics.vel.y = 0;\n            }\n            // Don't let left player pass under the net in beginning of point\n            if (this.accumulatedPointTime < _tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].ballPlayerLaunchTime &&\n                playerSide === _types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left &&\n                p.physics.center.x + p.physics.diameter / 2 >= this.gameConfig.net.center.x - this.gameConfig.net.width / 2) {\n                p.physics.center.x = this.gameConfig.net.center.x - this.gameConfig.net.width / 2 - p.physics.diameter / 2;\n            }\n            // Don't let right player pass under the net in beginning of point\n            if (this.accumulatedPointTime < _tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].ballPlayerLaunchTime &&\n                playerSide === _types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Right &&\n                p.physics.center.x - p.physics.diameter / 2 <= this.gameConfig.net.center.x + this.gameConfig.net.width / 2) {\n                p.physics.center.x = this.gameConfig.net.center.x + this.gameConfig.net.width / 2 + p.physics.diameter / 2;\n            }\n            // Left Wall\n            if (p.physics.center.x < p.physics.diameter / 2) {\n                p.physics.center.x = p.physics.diameter / 2;\n                if (p.physics.vel.x < 0)\n                    p.physics.vel.x = 0.0;\n            }\n            // Right Wall\n            if (p.physics.center.x > 1.0 - p.physics.diameter / 2) {\n                p.physics.center.x = 1.0 - p.physics.diameter / 2;\n                if (p.physics.vel.x > 0)\n                    p.physics.vel.x = 0.0;\n            }\n        }\n    }\n    manageCollisions(isSimulation) {\n        const ball0Alive = this.gameConfig.balls[0].isAlive;\n        const ball1Alive = this.gameConfig.balls[1].isAlive;\n        const ball0 = this.gameConfig.balls[0];\n        const ball1 = this.gameConfig.balls[1];\n        const player0 = this.gameConfig.player(_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left);\n        const player1 = this.gameConfig.player(_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Right);\n        // Collide ball0 with walls, net\n        if (ball0Alive) {\n            if (this.gameConfig.leftWall.handleBallCollision(ball0.physics, 1.0) && !isSimulation)\n                this.sound.playIfNotPlaying('thud', 0.6, 0.0, -1.0, false);\n            if (this.gameConfig.rightWall.handleBallCollision(ball0.physics, 1.0) && !isSimulation)\n                this.sound.playIfNotPlaying('thud', 0.6, 0.0, 1.0, false);\n            if (this.gameConfig.net.handleBallCollision(ball0.physics, 1.0) && !isSimulation)\n                this.sound.playIfNotPlaying('ding', 0.3, 0.0, 0.0, false);\n        }\n        // Collide ball1 with walls, net\n        if (ball1Alive) {\n            if (this.gameConfig.leftWall.handleBallCollision(ball1.physics, 1.0) && !isSimulation)\n                this.sound.playIfNotPlaying('thud', 1.0, 0.0, 1.0, false);\n            if (this.gameConfig.rightWall.handleBallCollision(ball1.physics, 1.0) && !isSimulation)\n                this.sound.playIfNotPlaying('thud', 1.0, 0.0, -1.0, false);\n            if (this.gameConfig.net.handleBallCollision(ball1.physics, 1.0) && !isSimulation)\n                this.sound.playIfNotPlaying('ding', 0.3, 0.0, 0.0, false);\n        }\n        // Ball-Ball collision\n        if (ball0Alive && ball1Alive) {\n            const collision = ball0.physics.handleHittingOtherCircle(ball1.physics, 1.0);\n            if (collision.didCollide && !isSimulation) {\n                const hardness = Math.min(1, _utils__WEBPACK_IMPORTED_MODULE_18__.vec.len(collision.c2MomentumDelta) / ball0.physics.mass / 5.0);\n                const pan = collision.pointOfContact.x;\n                const pitch = 1.0;\n                this.sound.playIfNotPlaying('beep', hardness, pitch, pan, false);\n            }\n        }\n        // Handle net collision for both players\n        this.gameConfig.net.handleBallCollision(player0.physics, 0.0);\n        this.gameConfig.net.handleBallCollision(player1.physics, 0.0);\n        // Ball-Player collisions\n        if (ball0Alive) {\n            this.manageBallPlayerCollision(isSimulation, ball0, player0, _types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left);\n            this.manageBallPlayerCollision(isSimulation, ball0, player1, _types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Right);\n        }\n        if (ball1Alive) {\n            this.manageBallPlayerCollision(isSimulation, ball1, player0, _types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left);\n            this.manageBallPlayerCollision(isSimulation, ball1, player1, _types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Right);\n        }\n        //\n        for (const playerSide of [_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left, _types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Right]) {\n            const i = playerSide === _types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left ? 0 : 1;\n            const player = this.gameConfig.player(playerSide);\n            const playerConfig = this.gameConfig.playerConfig(playerSide);\n            if (this.gameConfig.net.handleBallCollision(player.physics, 0.0) && !isSimulation) {\n                // do nothing; but the collision was detected and handled\n            }\n            if (!isSimulation || playerConfig.species === _player__WEBPACK_IMPORTED_MODULE_14__.PlayerSpecies.Human) {\n                for (const ball of this.gameConfig.balls) {\n                    if (ball.isAlive) {\n                        const collision = player.physics.handleHittingOtherCircle(ball.physics, 0.95);\n                        if (collision.didCollide && !isSimulation) {\n                            ball.setAngularVel(-300.0 + 600.0 * Math.random() * i);\n                            ball.setAngularVel(ball.physics.vel.x);\n                            const hardness = Math.min(1, _utils__WEBPACK_IMPORTED_MODULE_18__.vec.len(collision.c2MomentumDelta) / ball.physics.mass / 5.0);\n                            const pan = collision.pointOfContact.x - 0.5;\n                            const pitch = 1.0 -\n                                (2.0 * (player.physics.diameter - _tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].player.minDiameter)) /\n                                    (_tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].player.maxDiameter - _tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].player.minDiameter);\n                            this.sound.playIfNotPlaying('beep', hardness, pitch, pan, false);\n                        }\n                    }\n                }\n            }\n        }\n        // Player-player collisions\n        if (this.gameConfig.playerConfig(_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left).species !== _player__WEBPACK_IMPORTED_MODULE_14__.PlayerSpecies.Off &&\n            this.gameConfig.playerConfig(_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Right).species !== _player__WEBPACK_IMPORTED_MODULE_14__.PlayerSpecies.Off) {\n            const pLeft = this.gameConfig.player(_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left);\n            const pRight = this.gameConfig.player(_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Right);\n            pLeft.physics.handleHittingOtherCircle(pRight.physics, 0.0);\n        }\n    }\n    manageBallPlayerCollision(isSimulation, ball, player, playerSide) {\n        const collision = player.physics.handleHittingOtherCircle(ball.physics, 0.95);\n        const isLeft = playerSide === _types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left;\n        if (collision.didCollide && !isSimulation) {\n            ball.setAngularVel(-300.0 + 600.0 * Math.random() * (isLeft ? 0 : 1));\n            ball.setAngularVel(ball.physics.vel.x);\n            const hardness = Math.min(1, _utils__WEBPACK_IMPORTED_MODULE_18__.vec.len(collision.c2MomentumDelta) / ball.physics.mass / 5.0);\n            const pan = collision.pointOfContact.x - 0.5;\n            const pitch = 1.0 -\n                (2.0 * (player.physics.diameter - _tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].player.minDiameter)) / (_tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].player.maxDiameter - _tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].player.minDiameter);\n            this.sound.playIfNotPlaying('beep', hardness, pitch, pan, false);\n            // Slam\n            let amINearnet = false;\n            if (player.physics.center.x > this.gameConfig.net.center.x - (3 * this.gameConfig.net.width) / 2 &&\n                player.physics.center.x < this.gameConfig.net.center.x + (3 * this.gameConfig.net.width) / 2)\n                amINearnet = true;\n            let amIHittingItDown = false;\n            if ((isLeft && ball.physics.vel.x > 0 && ball.physics.vel.y < 0) || (!isLeft && ball.physics.vel.x < 0 && ball.physics.vel.y < 0))\n                amIHittingItDown = true;\n            let amIHighEnough = false;\n            if (player.physics.center.y > player.getMaxJumpHeight(_tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].gameGravity.y) / 2)\n                amIHighEnough = true;\n            if (amINearnet &&\n                amIHittingItDown &&\n                amIHighEnough &&\n                !this.historyManager.hasHappenedRecently(`Kapow-Slam-Player-${isLeft ? 0 : 1}`, this.currentGameTime, 0.75)) {\n                this.sound.play('slam', 0.3, 0.0, pan);\n                const dest = _utils__WEBPACK_IMPORTED_MODULE_18__.vec.add(collision.pointOfContact, { x: 0, y: 2 * ball.physics.diameter });\n                this.kapowManager.addAKapow(_kapow_manager__WEBPACK_IMPORTED_MODULE_12__.KapowType.Slam, dest, 0.0, 0.3, 1.5);\n                this.historyManager.recordEvent(`Kapow-Slam-Player-${isLeft ? 0 : 1}`, this.currentGameTime);\n            }\n            // Rejection\n            else if (hardness > 0.1 &&\n                ball.physics.vel.y > 1.0 &&\n                this.historyManager.hasHappenedRecently(`Kapow-Slam-Player-${isLeft ? 1 : 0}`, this.currentGameTime, 0.5) &&\n                !this.historyManager.hasHappenedRecently(`Kapow-Rejected-Player-${isLeft ? 0 : 1}`, this.currentGameTime, 0.25)) {\n                this.sound.playIfNotPlaying('rejected', 0.4, 0.1, 0.0, false);\n                this.kapowManager.addAKapow(_kapow_manager__WEBPACK_IMPORTED_MODULE_12__.KapowType.Rejected, collision.pointOfContact, 0.0, 0.3, 1.5);\n                this.historyManager.recordEvent(`Kapow-Rejected-Player-${isLeft ? 0 : 1}`, this.currentGameTime);\n            }\n        }\n    }\n    postPointStep() {\n        // For the first moments, don't move anything, but give ball & players big velocities\n        if (this.accumulatedStateTime < _tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].timeAfterPointToFreeze) {\n            for (const ball of this.gameConfig.balls) {\n                if (ball.isAlive) {\n                    ball.physics.vel = { x: 0, y: ball.maxSpeed };\n                }\n            }\n            for (const playerSide of [_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left, _types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Right]) {\n                const config = this.gameConfig.playerConfig(playerSide);\n                if (config.species !== _player__WEBPACK_IMPORTED_MODULE_14__.PlayerSpecies.Off) {\n                    const player = this.gameConfig.player(playerSide);\n                    player.physics.vel.x = 0.0;\n                    player.jump();\n                }\n            }\n        }\n        // Only move it after that\n        else {\n            const dt = this.currentGameTime.elapsedGameTime.totalMilliseconds / 1000;\n            for (let i = 0; i < 2; i++) {\n                const ball = this.gameConfig.balls[i];\n                if (ball.isAlive) {\n                    ball.stepVelocity(dt, _utils__WEBPACK_IMPORTED_MODULE_18__.vec.scale(_tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].gameGravity, 1.5), false);\n                    const xDestination = this.whoseServe === _types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left ? 0.25 : 0.75;\n                    const xDistance = xDestination - ball.physics.center.x;\n                    const timeTillStateSwitch = _tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].timeAfterPointToReturnHome - this.accumulatedStateTime;\n                    ball.physics.vel.x = (2 * xDistance) / timeTillStateSwitch;\n                    ball.stepPositionAndOrientation(dt);\n                }\n            }\n            for (const playerSide of [_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left, _types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Right]) {\n                const config = this.gameConfig.playerConfig(playerSide);\n                const player = this.gameConfig.player(playerSide);\n                if (config.species !== _player__WEBPACK_IMPORTED_MODULE_14__.PlayerSpecies.Off) {\n                    player.stepVelocity(dt, _tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].gameGravity);\n                    const xDestination = playerSide === _types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left ? 0.25 : 0.75;\n                    const xDistance = xDestination - player.physics.center.x;\n                    const timeTillStateSwitch = _tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].timeAfterPointToReturnHome - this.accumulatedStateTime;\n                    player.physics.vel.x = (2 * xDistance) / timeTillStateSwitch;\n                    player.stepPosition(dt);\n                }\n            }\n        }\n    }\n    gameStep(dt) {\n        if (!this.checkForAndScorePoint()) {\n            this.accumulatedGamePlayTime += dt;\n            for (const playerSide of [_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left, _types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Right]) {\n                const config = this.gameConfig.playerConfig(playerSide);\n                const player = this.gameConfig.player(playerSide);\n                if (config.species !== _player__WEBPACK_IMPORTED_MODULE_14__.PlayerSpecies.Off) {\n                    player.stepVelocity(dt, _tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].gameGravity);\n                    player.stepPosition(dt);\n                }\n            }\n            for (const ball of this.gameConfig.balls) {\n                if (ball.isAlive) {\n                    ball.stepVelocity(dt, _tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].gameGravity, true);\n                    ball.stepPositionAndOrientation(dt);\n                }\n            }\n            this.manageCollisions(false);\n            this.handleActionInputs(dt);\n            this.constrainPlayers();\n            return false;\n        }\n        else {\n            // Point has been scored; game state switched in checkForAndScorePoint()\n            return true;\n        }\n    }\n    simulateStep(dt) {\n        for (const playerSide of [_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left, _types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Right]) {\n            const config = this.gameConfig.playerConfig(playerSide);\n            const player = this.gameConfig.player(playerSide);\n            if (config.species !== _player__WEBPACK_IMPORTED_MODULE_14__.PlayerSpecies.Off) {\n                player.stepVelocity(dt, _tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].gameGravity);\n                player.stepPosition(dt);\n            }\n        }\n        for (const ball of this.gameConfig.balls) {\n            if (ball.isAlive) {\n                ball.stepVelocity(dt, _tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].gameGravity, true);\n                ball.stepPositionAndOrientation(dt);\n            }\n        }\n        this.manageCollisions(true);\n        this.constrainPlayers();\n    }\n    updateFuturePrediction() {\n        //return;\n        // Copy current player/ball info to temp so we can step w/o wrecking things\n        const sbTemp = [];\n        const p0Real = this.gameConfig.player(_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left);\n        const p1Real = this.gameConfig.player(_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Right);\n        const p0Copy = p0Real.deepCopy();\n        const p1Copy = p1Real.deepCopy();\n        for (let i = 0; i < this.gameConfig.balls.length; i++) {\n            sbTemp[i] = this.gameConfig.balls[i].deepCopy();\n            const prediction = this.futurePredictionList[i];\n            prediction.ballStates = [];\n            // Clear old important markers\n            prediction.ballHittingGround.isKnown = false;\n            prediction.ballCrossingNet.isKnown = false;\n            prediction.ballEnteringJumpRange(_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left).isKnown = false;\n            prediction.ballEnteringJumpRange(_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Right).isKnown = false;\n        }\n        let time = 0;\n        const timeElapsed = this.currentGameTime.totalGameTime.totalSeconds;\n        const p0JumpHeight = p0Copy.getMaxJumpHeight(_tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].gameGravity.y);\n        const p1JumpHeight = p1Copy.getMaxJumpHeight(_tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].gameGravity.y);\n        while (time < _tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].predictionLookahead) {\n            this.simulateStep(_tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].predictionPhysicsDt);\n            time += _tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].predictionPhysicsDt;\n            const currStep = (time + timeElapsed) / _tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].predictionStorageDt;\n            const lastStep = (time - _tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].predictionPhysicsDt + timeElapsed) / _tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].predictionStorageDt;\n            for (let i = 0; i < this.gameConfig.balls.length; i++) {\n                if (this.gameConfig.balls[i].isAlive) {\n                    const state = (0,_future_prediction__WEBPACK_IMPORTED_MODULE_8__.unknownState)();\n                    const ballPhysics = this.gameConfig.balls[i].physics;\n                    const prediction = this.futurePredictionList[i];\n                    state.pos = ballPhysics.center;\n                    state.time = time;\n                    if (Math.round(currStep) !== Math.round(lastStep)) {\n                        prediction.ballStates.push(state);\n                    }\n                    if (!prediction.ballHittingGround.isKnown && ballPhysics.center.y - ballPhysics.diameter / 2 <= 0.0) {\n                        prediction.ballHittingGround = state;\n                        prediction.ballHittingGround.isKnown = true;\n                    }\n                    else if (!prediction.ballCrossingNet.isKnown &&\n                        Math.abs(ballPhysics.center.x - this.gameConfig.net.center.x) < ballPhysics.diameter / 4.0) {\n                        prediction.ballCrossingNet = state;\n                        prediction.ballCrossingNet.isKnown = true;\n                    }\n                    if (!prediction.ballEnteringJumpRange(_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left).isKnown &&\n                        ballPhysics.center.x < this.gameConfig.net.center.x - this.gameConfig.net.width / 2 &&\n                        ballPhysics.center.y <= p0JumpHeight) {\n                        state.isKnown = true;\n                        prediction.setBallEnteringJumpRange(_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left, state);\n                    }\n                    if (!prediction.ballEnteringJumpRange(_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Right).isKnown &&\n                        ballPhysics.center.x > this.gameConfig.net.center.x + this.gameConfig.net.width / 2 &&\n                        ballPhysics.center.y <= p1JumpHeight) {\n                        state.isKnown = true;\n                        prediction.setBallEnteringJumpRange(_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Right, state);\n                    }\n                }\n            }\n        }\n        for (let i = 0; i < this.gameConfig.balls.length; i++) {\n            if (this.gameConfig.balls[i].isAlive) {\n                this.gameConfig.balls[i] = sbTemp[i];\n            }\n        }\n        this.gameConfig.setPlayer(_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Left, p0Copy);\n        this.gameConfig.setPlayer(_types__WEBPACK_IMPORTED_MODULE_17__.PlayerSide.Right, p1Copy);\n    }\n    runActionState() {\n        const dt = this.currentGameTime.elapsedGameTime.totalMilliseconds / 1000;\n        let physicsDtCountdown = dt;\n        let pointScored = false;\n        if (this.currentGameTime.totalGameTime.totalMilliseconds > this.lastFuturePrediction + _tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].predictFutureEvery) {\n            this.updateFuturePrediction();\n            this.lastFuturePrediction = this.currentGameTime.totalGameTime.totalMilliseconds;\n        }\n        while (physicsDtCountdown > 0 && !pointScored) {\n            const delta = Math.min(_tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].physicsDt, physicsDtCountdown);\n            pointScored = this.gameStep(delta);\n            physicsDtCountdown -= delta;\n        }\n        this.aIStep();\n    }\n    runMainMenuState() {\n        this.handleMenuInputs();\n    }\n    runPreExitState() {\n        this.handlePreExitInputs();\n    }\n    runIntroState() {\n        this.handleIntroInputs();\n    }\n    runPausedState() {\n        this.handleMenuInputs();\n    }\n    runAutoPausedState() {\n        this.handleAutoPausedInputs();\n    }\n    runInstructionsState() {\n        this.handleInstructionsInputs();\n    }\n    runPointState() {\n        this.postPointStep();\n        this.handlePointInputs();\n    }\n    runPreActionState() {\n        this.handlePreActionInputs();\n    }\n    runVictoryState() {\n        this.handleVictoryInputs();\n    }\n    handleUniversalInputs() {\n        if (this.input.wasDebugKeyJustPushed()) {\n            this.display.inDebugView = !this.display.inDebugView;\n        }\n    }\n    getMaxHeightOfAllBalls() {\n        let highest = -10.0;\n        for (const ball of this.gameConfig.balls) {\n            if (ball.isAlive)\n                highest = Math.max(highest, ball.physics.getBallMaxHeight(_tweakables__WEBPACK_IMPORTED_MODULE_16__[\"default\"].gameGravity));\n        }\n        return highest;\n    }\n    update(gameTime) {\n        if (this.gameState === _types__WEBPACK_IMPORTED_MODULE_17__.GameState.PreStart) {\n            this.setGameState(_types__WEBPACK_IMPORTED_MODULE_17__.GameState.Intro1);\n        }\n        this.handleUniversalInputs();\n        const dt = gameTime.elapsedGameTime.totalMilliseconds / 1000;\n        this.accumulatedStateTime += dt;\n        if (this.gameState === _types__WEBPACK_IMPORTED_MODULE_17__.GameState.Action)\n            this.accumulatedPointTime += dt;\n        switch (this.gameState) {\n            case _types__WEBPACK_IMPORTED_MODULE_17__.GameState.Action:\n                this.display.adjustZoomLevel(this.getMaxHeightOfAllBalls(), dt);\n                this.runActionState();\n                break;\n            case _types__WEBPACK_IMPORTED_MODULE_17__.GameState.Paused:\n                this.display.adjustZoomLevel(1000, dt);\n                this.runPausedState();\n                break;\n            case _types__WEBPACK_IMPORTED_MODULE_17__.GameState.AutoPaused:\n                this.display.adjustZoomLevel(1000, dt);\n                this.runAutoPausedState();\n                break;\n            case _types__WEBPACK_IMPORTED_MODULE_17__.GameState.Instructions:\n                this.display.adjustZoomLevel(1000, dt);\n                this.runInstructionsState();\n                break;\n            case _types__WEBPACK_IMPORTED_MODULE_17__.GameState.MainMenu:\n                this.runMainMenuState();\n                break;\n            case _types__WEBPACK_IMPORTED_MODULE_17__.GameState.Intro1:\n            case _types__WEBPACK_IMPORTED_MODULE_17__.GameState.Intro2:\n            case _types__WEBPACK_IMPORTED_MODULE_17__.GameState.Intro3:\n                this.runIntroState();\n                break;\n            case _types__WEBPACK_IMPORTED_MODULE_17__.GameState.PointForPlayer0:\n            case _types__WEBPACK_IMPORTED_MODULE_17__.GameState.PointForPlayer1:\n                this.runPointState();\n                break;\n            case _types__WEBPACK_IMPORTED_MODULE_17__.GameState.PreAction:\n                this.runPreActionState();\n                break;\n            case _types__WEBPACK_IMPORTED_MODULE_17__.GameState.VictoryForPlayer0:\n            case _types__WEBPACK_IMPORTED_MODULE_17__.GameState.VictoryForPlayer1:\n                this.display.adjustZoomLevel(1000, dt);\n                this.runVictoryState();\n                break;\n            case _types__WEBPACK_IMPORTED_MODULE_17__.GameState.PreExitMessage:\n            case _types__WEBPACK_IMPORTED_MODULE_17__.GameState.PreExitCredits:\n                this.runPreExitState();\n                break;\n            case _types__WEBPACK_IMPORTED_MODULE_17__.GameState.Exit:\n                return false;\n        }\n        return true;\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/game.ts?");

/***/ }),

/***/ "./src/gamepad-monitor.ts":
/*!********************************!*\
  !*** ./src/gamepad-monitor.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GamepadMonitor\": () => (/* binding */ GamepadMonitor)\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\nclass GamepadMonitor {\n    constructor() {\n        this.unassigned = [];\n        this.currAssigned = new Map();\n        this.prevAssigned = new Map();\n        this.prevState = new Map();\n        this.currState = new Map();\n        window.addEventListener('gamepadconnected', (e) => this.connect(e.gamepad));\n        window.addEventListener('gamepaddisconnected', (e) => this.disconnect(e.gamepad));\n        this.pollingLoop();\n    }\n    update() {\n        this.prevState = new Map();\n        for (const [gamepadId, gamepadState] of this.currState.entries()) {\n            this.prevState.set(gamepadId, gamepadState);\n        }\n        this.currState = new Map();\n        const gamepads = navigator.getGamepads();\n        for (const gamepad of gamepads) {\n            if (gamepad) {\n                const state = this.getStateFromGamepad(gamepad);\n                this.currState.set(gamepad.id, state);\n            }\n        }\n        this.prevAssigned = new Map(this.currAssigned);\n    }\n    swapSides() {\n        console.log(`Swapping controller sides`);\n        const prevLeft = this.currAssigned.get(_types__WEBPACK_IMPORTED_MODULE_0__.PlayerSide.Left);\n        const prevRight = this.currAssigned.get(_types__WEBPACK_IMPORTED_MODULE_0__.PlayerSide.Right);\n        this.currAssigned = new Map();\n        if (prevLeft)\n            this.currAssigned.set(_types__WEBPACK_IMPORTED_MODULE_0__.PlayerSide.Right, prevLeft);\n        if (prevRight)\n            this.currAssigned.set(_types__WEBPACK_IMPORTED_MODULE_0__.PlayerSide.Left, prevRight);\n    }\n    wasPlayerJustDisconnected(playerSide) {\n        return !this.currAssigned.has(playerSide) && this.prevAssigned.has(playerSide);\n    }\n    wasPlayerJustConnected(playerSide) {\n        return this.currAssigned.has(playerSide) && !this.prevAssigned.has(playerSide);\n    }\n    doesPlayerHaveGamepad(playerSide) {\n        return this.currAssigned.has(playerSide);\n    }\n    anyButtonsPushedByAnyone(buttonNames) {\n        for (const playerSide of this.currAssigned.keys()) {\n            const found = this.anyButtonsPushedBy(playerSide, buttonNames);\n            if (found)\n                return true;\n        }\n        return false;\n    }\n    anyButtonDown(playerSide, buttonNames) {\n        const gamepad = this.currAssigned.get(playerSide);\n        if (gamepad) {\n            for (const buttonName of buttonNames) {\n                const currState = this.currState.get(gamepad.id);\n                if (currState) {\n                    if (currState.buttons[buttonName]) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    anyButtonsPushedBy(playerSide, buttonNames) {\n        const gamepad = this.currAssigned.get(playerSide);\n        if (gamepad) {\n            for (const buttonName of buttonNames) {\n                const currState = this.currState.get(gamepad.id);\n                const prevState = this.prevState.get(gamepad.id);\n                const currPushed = currState && currState.buttons[buttonName];\n                const prevPushed = prevState && prevState.buttons[buttonName];\n                if (currPushed && !prevPushed) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    getTrigger(playerSide, triggerName) {\n        const gamepad = this.currAssigned.get(playerSide);\n        if (gamepad) {\n            const state = this.currState.get(gamepad.id);\n            if (state)\n                return state.triggers[triggerName];\n            else\n                0;\n        }\n        return 0;\n    }\n    getThumbStick(playerSide, thumbstickName) {\n        const gamepad = this.currAssigned.get(playerSide);\n        if (gamepad) {\n            const state = this.currState.get(gamepad.id);\n            if (state)\n                return state.thumbSticks[thumbstickName];\n            else\n                return { x: 0, y: 0 };\n        }\n        return { x: 0, y: 0 };\n    }\n    getStateFromPlayer(playerSide) {\n        const gp = this.currAssigned.get(playerSide);\n        const prev = this.prevAssigned.get(playerSide);\n        if (!gp || !prev)\n            return null;\n        return this.getStateFromGamepad(gp);\n    }\n    getStateFromGamepad(gamepad) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n        const { buttons, axes } = gamepad;\n        return {\n            isConnected: true,\n            triggers: {\n                left: buttons[6].value,\n                right: buttons[7].value,\n            },\n            thumbSticks: {\n                left: { x: axes[0], y: axes[1] },\n                right: { x: axes[2], y: axes[3] },\n            },\n            buttons: {\n                dPadUp: ((_a = buttons[12]) === null || _a === void 0 ? void 0 : _a.pressed) || false,\n                dPadDown: ((_b = buttons[13]) === null || _b === void 0 ? void 0 : _b.pressed) || false,\n                dPadLeft: ((_c = buttons[14]) === null || _c === void 0 ? void 0 : _c.pressed) || false,\n                dPadRight: ((_d = buttons[15]) === null || _d === void 0 ? void 0 : _d.pressed) || false,\n                psX: ((_e = gamepad.buttons[0]) === null || _e === void 0 ? void 0 : _e.pressed) || false,\n                psO: ((_f = gamepad.buttons[1]) === null || _f === void 0 ? void 0 : _f.pressed) || false,\n                start: ((_g = gamepad.buttons[9]) === null || _g === void 0 ? void 0 : _g.pressed) || false,\n                leftStick: ((_h = gamepad.buttons[10]) === null || _h === void 0 ? void 0 : _h.pressed) || false,\n                rightStick: ((_j = gamepad.buttons[11]) === null || _j === void 0 ? void 0 : _j.pressed) || false,\n                rightShoulder: ((_k = gamepad.buttons[5]) === null || _k === void 0 ? void 0 : _k.pressed) || false,\n            },\n        };\n    }\n    // some older browsers may miss a connect/disconnect\n    // annoying that this has to exist\n    pollingLoop() {\n        return __awaiter(this, void 0, void 0, function* () {\n            while (true) {\n                yield (0,_utils__WEBPACK_IMPORTED_MODULE_1__.timeout)(500);\n                const gamepads = navigator.getGamepads().filter((gp) => gp !== null);\n                // notice anything new connected\n                for (const gamepad of gamepads) {\n                    if (!this.isKnownYet(gamepad)) {\n                        this.connect(gamepad);\n                    }\n                }\n                // notice anything previously connected that disappeared\n                for (const prev of this.getAssignedAndUnassigned()) {\n                    if (gamepads.filter((gp) => gp.id === prev.id).length === 0) {\n                        this.disconnect(prev);\n                    }\n                }\n            }\n        });\n    }\n    getAssignedAndUnassigned() {\n        return Array.from(this.currAssigned.values()).concat(this.unassigned);\n    }\n    isKnownYet(gamepad) {\n        for (const candidate of this.getAssignedAndUnassigned()) {\n            if (gamepad.id === candidate.id)\n                return true;\n        }\n        return false;\n    }\n    connect(gamepad) {\n        if (!this.isKnownYet(gamepad)) {\n            this.unassigned.push(gamepad);\n            console.log('connected', gamepad);\n            this.updateAssignments();\n        }\n    }\n    updateAssignments() {\n        for (const pSide of [_types__WEBPACK_IMPORTED_MODULE_0__.PlayerSide.Left, _types__WEBPACK_IMPORTED_MODULE_0__.PlayerSide.Right]) {\n            if (!this.currAssigned.get(pSide) && this.unassigned.length) {\n                const gamePad = this.unassigned.splice(0, 1)[0];\n                this.currAssigned.set(pSide, gamePad);\n            }\n        }\n    }\n    disconnect(gamepad) {\n        // remove from assigned\n        for (const pSide of [_types__WEBPACK_IMPORTED_MODULE_0__.PlayerSide.Left, _types__WEBPACK_IMPORTED_MODULE_0__.PlayerSide.Right]) {\n            const gamePad = this.currAssigned.get(pSide);\n            if (gamePad && gamePad.id === gamepad.id) {\n                console.log('disconnected from assigned', gamepad);\n                this.currAssigned.delete(pSide);\n            }\n        }\n        // remove from unassigned\n        this.unassigned = this.unassigned.filter((u) => u.id !== gamepad.id);\n        this.updateAssignments();\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/gamepad-monitor.ts?");

/***/ }),

/***/ "./src/history-manager.ts":
/*!********************************!*\
  !*** ./src/history-manager.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"HistoryManager\": () => (/* binding */ HistoryManager)\n/* harmony export */ });\nclass HistoryManager {\n    constructor() {\n        this.lastTimeRecorder = new Map();\n    }\n    recordEvent(eventName, gameTime) {\n        this.lastTimeRecorder.set(eventName, gameTime.totalGameTime.totalSeconds);\n    }\n    hasHappenedRecently(eventName, gameTime, seconds) {\n        const lastTime = this.lastTimeRecorder.get(eventName);\n        if (!lastTime)\n            return false;\n        if (gameTime.totalGameTime.totalSeconds - lastTime > seconds)\n            return false;\n        return true;\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/history-manager.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _page_ui__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./page-ui */ \"./src/page-ui.ts\");\n\nconst el = document.getElementById('tcftg-wrapper');\nnew _page_ui__WEBPACK_IMPORTED_MODULE_0__.PageUi(el);\n\n\n//# sourceURL=webpack:///./src/index.ts?");

/***/ }),

/***/ "./src/input.ts":
/*!**********************!*\
  !*** ./src/input.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Input\": () => (/* binding */ Input)\n/* harmony export */ });\n/* harmony import */ var _gamepad_monitor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gamepad-monitor */ \"./src/gamepad-monitor.ts\");\n/* harmony import */ var _keyboard_monitor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keyboard-monitor */ \"./src/keyboard-monitor.ts\");\n/* harmony import */ var _player__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./player */ \"./src/player.ts\");\n/* harmony import */ var _tweakables__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tweakables */ \"./src/tweakables.ts\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\n\n\n\n\n\nclass Input {\n    constructor(gameConfig) {\n        this.gameConfig = gameConfig;\n        this.pads = new _gamepad_monitor__WEBPACK_IMPORTED_MODULE_0__.GamepadMonitor();\n        this.keyboard = new _keyboard_monitor__WEBPACK_IMPORTED_MODULE_1__.KeyboardMonitor();\n    }\n    updateInputStates() {\n        this.keyboard.update();\n        this.pads.update();\n    }\n    isKeyboardConnected() {\n        return true; // for now\n    }\n    getKeyboardSet(pI) {\n        const rightPlayerConfig = this.gameConfig.playerConfig(_types__WEBPACK_IMPORTED_MODULE_4__.PlayerSide.Right);\n        const isTwoPlayerGame = rightPlayerConfig.species === _player__WEBPACK_IMPORTED_MODULE_2__.PlayerSpecies.Human;\n        const kSet = isTwoPlayerGame ? _tweakables__WEBPACK_IMPORTED_MODULE_3__[\"default\"].twoPlayerControls : _tweakables__WEBPACK_IMPORTED_MODULE_3__[\"default\"].onePlayerControls;\n        if (pI === _types__WEBPACK_IMPORTED_MODULE_4__.PlayerSide.Left)\n            return kSet.p0;\n        else\n            return kSet.p1;\n    }\n    swapGamepadSides() {\n        this.pads.swapSides();\n    }\n    wasKeyboardPauseHit() {\n        return this.keyboard.anyKeysJustPushed(['Enter', 'Space']);\n    }\n    checkGamepadPauseHit() {\n        for (const pI of [_types__WEBPACK_IMPORTED_MODULE_4__.PlayerSide.Left, _types__WEBPACK_IMPORTED_MODULE_4__.PlayerSide.Right]) {\n            if (this.pads.anyButtonsPushedBy(pI, ['start']))\n                return pI;\n        }\n        return null;\n    }\n    wasMenuSelectJustPushed(owner) {\n        const res = {\n            selected: false,\n            byPlayerSide: null,\n            byKeyboard: false,\n        };\n        if (this.keyboard.anyKeysJustPushed(['Enter', 'Space'])) {\n            res.selected = true;\n            res.byKeyboard = true;\n        }\n        else {\n            const toCheck = owner ? [owner] : [_types__WEBPACK_IMPORTED_MODULE_4__.PlayerSide.Left, _types__WEBPACK_IMPORTED_MODULE_4__.PlayerSide.Right];\n            for (const playerSide of toCheck) {\n                if (this.pads.anyButtonsPushedBy(playerSide, ['psX'])) {\n                    res.selected = true;\n                    res.byPlayerSide = playerSide;\n                }\n            }\n        }\n        return res;\n    }\n    wasMenuUpJustPushed(owner) {\n        if (this.keyboard.anyKeysJustPushed(['KeyI', 'KeyW', 'ArrowUp']))\n            return true;\n        if (owner) {\n            return this.pads.anyButtonsPushedBy(owner, ['dPadUp']);\n        }\n        else {\n            return this.pads.anyButtonsPushedByAnyone(['dPadUp']);\n        }\n    }\n    wasMenuDownJustPushed(owner) {\n        if (this.keyboard.anyKeysJustPushed(['KeyS', 'KeyK', 'ArrowDown']))\n            return true;\n        if (owner) {\n            return this.pads.anyButtonsPushedBy(owner, ['dPadDown']);\n        }\n        else {\n            return this.pads.anyButtonsPushedByAnyone(['dPadDown']);\n        }\n    }\n    wasMenuExitJustPushed(owner) {\n        if (owner)\n            return this.pads.anyButtonsPushedBy(owner, ['psO', 'start']);\n        else\n            return this.pads.anyButtonsPushedByAnyone(['psO', 'start']);\n    }\n    wasPostgameProceedJustPushed() {\n        return this.pads.anyButtonsPushedByAnyone(['psO', 'psX', 'start']) || this.wasMenuSelectJustPushed(null).selected;\n    }\n    wasPlayerJustDisconnectedFromGamepad(playerSide) {\n        return this.pads.wasPlayerJustDisconnected(playerSide);\n    }\n    wasPlayerJustConnectedToGamepad(playerSide) {\n        return this.pads.wasPlayerJustConnected(playerSide);\n    }\n    doesPlayerHaveGamepad(playerSide) {\n        return this.pads.doesPlayerHaveGamepad(playerSide);\n    }\n    gamepadConnectSummary() {\n        return {\n            left: this.pads.getStateFromPlayer(_types__WEBPACK_IMPORTED_MODULE_4__.PlayerSide.Left),\n            right: this.pads.getStateFromPlayer(_types__WEBPACK_IMPORTED_MODULE_4__.PlayerSide.Right),\n        };\n    }\n    isJumpPressed(pI) {\n        const set = this.getKeyboardSet(pI);\n        return this.keyboard.anyKeyDown(set.jump) || this.pads.anyButtonDown(pI, ['psX']);\n    }\n    /**\n     * returns 0 if trigger near 0, within tolerance\n     * defined in tweakables. otherwise returns value up to 1\n     */\n    getTrigger(playerSide, triggerName) {\n        const x = this.pads.getTrigger(playerSide, triggerName);\n        if (x < _tweakables__WEBPACK_IMPORTED_MODULE_3__[\"default\"].triggerTolerance)\n            return 0;\n        return x;\n    }\n    /**\n     * returns 0 if thumbstick near the middle, within tolerance\n     * defined in tweakables. otherwise returns value\n     * @param playerSide - playerSide\n     */\n    getLeftThumbStickX(playerSide) {\n        const x = this.pads.getThumbStick(playerSide, 'left').x;\n        if (Math.abs(x) < _tweakables__WEBPACK_IMPORTED_MODULE_3__[\"default\"].thumbstickCenterTolerance)\n            return 0;\n        else\n            return x;\n    }\n    isLeftPressed(pI) {\n        const set = this.getKeyboardSet(pI);\n        const keyboardLeft = this.keyboard.anyKeyDown(set.left) && !this.keyboard.anyKeyDown(set.right);\n        const dPadLeft = this.pads.anyButtonDown(pI, ['dPadLeft']);\n        return keyboardLeft || dPadLeft;\n    }\n    isRightPressed(pI) {\n        const set = this.getKeyboardSet(pI);\n        const keyboardRight = this.keyboard.anyKeyDown(set.right) && !this.keyboard.anyKeyDown(set.left);\n        const dPadRight = this.pads.anyButtonDown(pI, ['dPadRight']);\n        return keyboardRight || dPadRight;\n    }\n    isGrowPressed(pI) {\n        const set = this.getKeyboardSet(pI);\n        return this.keyboard.anyKeyDown(set.grow);\n    }\n    isShrinkPressed(pI) {\n        const set = this.getKeyboardSet(pI);\n        return this.keyboard.anyKeyDown(set.shrink);\n    }\n    wasDebugKeyJustPushed() {\n        return this.keyboard.anyKeysJustPushed(['KeyG']);\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/input.ts?");

/***/ }),

/***/ "./src/kapow-manager.ts":
/*!******************************!*\
  !*** ./src/kapow-manager.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Kapow\": () => (/* binding */ Kapow),\n/* harmony export */   \"KapowManager\": () => (/* binding */ KapowManager),\n/* harmony export */   \"KapowType\": () => (/* binding */ KapowType)\n/* harmony export */ });\nvar KapowType;\n(function (KapowType) {\n    KapowType[\"Slam\"] = \"slam\";\n    KapowType[\"Rejected\"] = \"rejected\";\n    KapowType[\"Score\"] = \"score\";\n})(KapowType || (KapowType = {}));\nclass Kapow {\n    constructor(kapowType, pos, orientation, size, maxAge) {\n        this.age = 0;\n        this.kapowType = kapowType;\n        this.pos = pos;\n        this.orientation = orientation;\n        this.maxAge = maxAge;\n        this.size = size;\n    }\n    stepAndTestForDeath(dt) {\n        this.age += dt;\n        this.size += dt / 40;\n        return this.age >= this.maxAge;\n    }\n    fractionOfWayToDeath() {\n        return this.age / this.maxAge;\n    }\n}\nclass KapowManager {\n    constructor() {\n        this.kapows = [];\n    }\n    addAKapow(kapowType, pos, orientation, size, maxAge) {\n        this.kapows.push(new Kapow(kapowType, pos, orientation, size, maxAge));\n    }\n    step(dt) {\n        for (let i = this.kapows.length - 1; i >= 0; i--) {\n            if (this.kapows[i].stepAndTestForDeath(dt))\n                this.kapows.splice(i, 1);\n        }\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/kapow-manager.ts?");

/***/ }),

/***/ "./src/keyboard-monitor.ts":
/*!*********************************!*\
  !*** ./src/keyboard-monitor.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"KeyboardMonitor\": () => (/* binding */ KeyboardMonitor)\n/* harmony export */ });\nclass KeyboardMonitor {\n    constructor() {\n        this.keysDown = new Set();\n        this.prevKeysDown = new Set();\n        this.registerKeyboardActions();\n    }\n    update() {\n        this.prevKeysDown = new Set(this.keysDown);\n    }\n    isKeyDown(code) {\n        return this.keysDown.has(code);\n    }\n    anyKeyDown(codes) {\n        for (const c of codes) {\n            if (this.isKeyDown(c))\n                return true;\n        }\n        return false;\n    }\n    anyKeysJustPushed(codes) {\n        for (const c of codes) {\n            if (this.wasKeyJustPushed(c))\n                return true;\n        }\n        return false;\n    }\n    wasKeyJustPushed(code) {\n        if (!this.prevKeysDown)\n            return false;\n        const isPressed = this.keysDown.has(code);\n        const wasPressed = this.prevKeysDown.has(code);\n        if (this.prevKeysDown.size !== this.keysDown.size)\n            return isPressed && !wasPressed;\n        return false;\n    }\n    // ---- PRIVACY PLEASE\n    registerKeyboardActions() {\n        window.addEventListener('keydown', (event) => {\n            this.keysDown.add(event.code);\n        });\n        window.addEventListener('keyup', (event) => {\n            this.keysDown.delete(event.code);\n        });\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/keyboard-monitor.ts?");

/***/ }),

/***/ "./src/menu.ts":
/*!*********************!*\
  !*** ./src/menu.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Menu\": () => (/* binding */ Menu),\n/* harmony export */   \"MenuOptions\": () => (/* binding */ MenuOptions)\n/* harmony export */ });\n/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color */ \"./src/color.ts\");\n/* harmony import */ var _tweakables__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tweakables */ \"./src/tweakables.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\n\n\n\nvar MenuOptions;\n(function (MenuOptions) {\n    MenuOptions[\"ReturnToGame\"] = \"return-to-game\";\n    MenuOptions[\"Play2Player1Ball\"] = \"play-2-player-1-ball\";\n    MenuOptions[\"Play2Player2Balls\"] = \"play-2-player-2-balls\";\n    MenuOptions[\"PlayGreen\"] = \"play-green\";\n    MenuOptions[\"PlayPurple\"] = \"play-purple\";\n    MenuOptions[\"PlayOrange\"] = \"play-orange\";\n    MenuOptions[\"PlayBlack\"] = \"play-black\";\n    MenuOptions[\"PlayWhite\"] = \"play-white\";\n    MenuOptions[\"Instructions\"] = \"instructions\";\n    MenuOptions[\"Exit\"] = \"exit\";\n})(MenuOptions || (MenuOptions = {}));\nclass Menu {\n    constructor(display) {\n        this.allowReturnToGame = true;\n        this.display = display;\n        this.menuItems = [];\n        this.menuItems.push({ text: 'Return to Game', option: MenuOptions.ReturnToGame });\n        this.menuItems.push({ text: '2-Players, 1-Ball', option: MenuOptions.Play2Player1Ball });\n        this.menuItems.push({ text: '2-Players, 2-Balls', option: MenuOptions.Play2Player2Balls });\n        this.menuItems.push({ text: 'Challenge Green', option: MenuOptions.PlayGreen });\n        this.menuItems.push({ text: 'Challenge Black', option: MenuOptions.PlayBlack });\n        this.menuItems.push({ text: 'Challenge Purple', option: MenuOptions.PlayPurple });\n        this.menuItems.push({ text: 'Challenge White', option: MenuOptions.PlayWhite });\n        this.menuItems.push({ text: 'Instructions', option: MenuOptions.Instructions });\n        this.menuItems.push({ text: 'Exit', option: MenuOptions.Exit });\n        this.selectedMenuItem = 1;\n        this.playerOwnsMenu = null;\n    }\n    get spriteBatch() {\n        return this.display.getSpriteBatch();\n    }\n    get canvasWidth() {\n        return this.display.canvasWidth;\n    }\n    get canvasHeight() {\n        return this.display.canvasHeight;\n    }\n    select(num, playerSide) {\n        if (this.playerOwnsMenu === null || this.playerOwnsMenu === playerSide) {\n            this.selectedMenuItem = num;\n        }\n    }\n    draw(allowReturnToGame, gameTime) {\n        const seconds = gameTime.totalGameTime.totalSeconds;\n        const beat = 2.0 * Math.PI * seconds * (_tweakables__WEBPACK_IMPORTED_MODULE_1__[\"default\"].menu.bpm / 60);\n        this.allowReturnToGame = allowReturnToGame;\n        if (!allowReturnToGame && this.selectedMenuItem == 0) {\n            this.selectedMenuItem = 1;\n        }\n        let lineSpacing = { x: 0, y: -0.1 };\n        if (allowReturnToGame) {\n            lineSpacing = _utils__WEBPACK_IMPORTED_MODULE_2__.vec.scale(lineSpacing, 0.9);\n        }\n        const startPosition = { x: 0.1, y: 0.9 };\n        const destination = startPosition;\n        for (let i = allowReturnToGame ? 0 : 1; i < this.menuItems.length; i++) {\n            destination.y += lineSpacing.y;\n            if (i == 3 || i == 5 || i == 7 || (i == 1 && allowReturnToGame)) {\n                destination.y -= 0.1;\n                const rect = {\n                    x1: destination.x,\n                    y1: destination.y - 0.14,\n                    x2: destination.x + 0.8,\n                    y2: destination.y - 0.15,\n                };\n                const texture = this.display.getTexture('menuDivider');\n                this.spriteBatch.drawTextureInRect(texture, rect, 1);\n                destination.y += 0.01;\n            }\n            let sizeMultiplier = 0.1;\n            let r = 0.0; // rotation\n            if (i === this.selectedMenuItem) {\n                sizeMultiplier += 0.1 + Math.sin(beat / 2) / 20 + Math.sin(beat / 8) / 20;\n                r = -0.1 + Math.sin(beat) / 32;\n            }\n            let backgroundColor = new _color__WEBPACK_IMPORTED_MODULE_0__.Color(0.0, 0.0, 0.0, 0.75);\n            let backgroundColor2 = new _color__WEBPACK_IMPORTED_MODULE_0__.Color(0.0, 0.0, 0.0, 0.15);\n            let foregroundColor = _color__WEBPACK_IMPORTED_MODULE_0__.Colors.white;\n            if (i !== this.selectedMenuItem) {\n                foregroundColor = new _color__WEBPACK_IMPORTED_MODULE_0__.Color(foregroundColor.r, foregroundColor.g, foregroundColor.b, 0.75);\n                backgroundColor = new _color__WEBPACK_IMPORTED_MODULE_0__.Color(0.0, 0.0, 0.0, 0); //.05)  // invisible for now\n                backgroundColor2 = new _color__WEBPACK_IMPORTED_MODULE_0__.Color(0.0, 0.0, 0.0, 0); //.05) // invisible for now\n                r = -0.003 + Math.sin(beat + i) / (200 + i);\n            }\n            const p0 = _utils__WEBPACK_IMPORTED_MODULE_2__.vec.add(destination, { x: -0.01, y: -0.01 });\n            const p1 = _utils__WEBPACK_IMPORTED_MODULE_2__.vec.add(destination, { x: 0.01, y: 0.02 });\n            const p2 = destination;\n            const font = this.display.font('extraBold');\n            this.spriteBatch.drawStringUncentered(this.menuItems[i].text, font, sizeMultiplier, p0, backgroundColor2, r);\n            this.spriteBatch.drawStringUncentered(this.menuItems[i].text, font, sizeMultiplier, p1, backgroundColor, r);\n            this.spriteBatch.drawStringUncentered(this.menuItems[i].text, font, sizeMultiplier, p2, foregroundColor, r);\n        }\n        if (this.selectedMenuItem >= 1 && this.selectedMenuItem <= 6) {\n            const p = { x: (2 * this.canvasWidth) / 3, y: (2 * this.canvasHeight) / 3 };\n            this.display.drawMenuBanner(this.getBannerTexture(this.selectedMenuItem), gameTime, p);\n        }\n    }\n    getBannerTexture(menuItem) {\n        switch (menuItem) {\n            case 1:\n                return this.display.getTexture('menuBanner2Player1Ball');\n            case 2:\n                return this.display.getTexture('menuBanner2Player2Balls');\n            case 3:\n                return this.display.getTexture('menuBannerGreen');\n            case 4:\n                return this.display.getTexture('menuBannerBlack');\n            case 5:\n                return this.display.getTexture('menuBannerPurple');\n            default:\n                return this.display.getTexture('menuBannerWhite');\n        }\n    }\n    moveDown(owner) {\n        if (this.playerOwnsMenu === null || this.playerOwnsMenu === owner) {\n            this.selectedMenuItem = (this.selectedMenuItem + 1) % this.menuItems.length;\n            if (this.selectedMenuItem == 0 && !this.allowReturnToGame)\n                this.selectedMenuItem++;\n        }\n    }\n    moveUp(owner) {\n        if (this.playerOwnsMenu === null || this.playerOwnsMenu === owner) {\n            this.selectedMenuItem--;\n            if ((this.selectedMenuItem == 0 && !this.allowReturnToGame) || this.selectedMenuItem < 0)\n                this.selectedMenuItem = this.menuItems.length - 1;\n        }\n    }\n    returnSelection() {\n        return this.menuItems[this.selectedMenuItem].option;\n    }\n    getWhoOwnsMenu() {\n        return this.playerOwnsMenu;\n    }\n    setWhoOwnsMenu(playerSide) {\n        this.playerOwnsMenu = playerSide;\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/menu.ts?");

/***/ }),

/***/ "./src/page-ui.ts":
/*!************************!*\
  !*** ./src/page-ui.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PageUi\": () => (/* binding */ PageUi)\n/* harmony export */ });\n/* harmony import */ var _game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./game */ \"./src/game.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\nclass PageUi {\n    constructor(parentEl) {\n        this.runYet = false;\n        this.parentEl = parentEl;\n        this.generateLayout();\n        const canvasWrapper = this.findDiv('#game-canvas-wrapper');\n        this.game = new _game__WEBPACK_IMPORTED_MODULE_0__.Game(canvasWrapper, (s) => this.contentLoadMonitor(s));\n    }\n    lPad(n, len) {\n        let s = `${n}`;\n        while (s.length < len)\n            s = `0${s}`;\n        return s;\n    }\n    contentLoadMonitor(s) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const $el = document.getElementById('load-stats');\n            const w = 100;\n            const leftW = 1 + (s.done / s.total) * w;\n            const rightW = 1 + w - leftW;\n            let text = `${s.done === s.total ? '✅' : '🔥'} ${this.lPad(s.done, 3)}/${s.total} textures &amp; sounds.`;\n            if (this.runYet)\n                text = 'Almost there...will launch when loaded';\n            if ($el)\n                $el.innerHTML = `\n    <div style=\"display:inline-block;width:${leftW}px;height:11px;background-color:#00f\"></div><div style=\"display:inline-block;width:${rightW}px;height:10px;background-color:#eee\"></div>\n    ${text}\n    `;\n            if (s.done === s.total) {\n                const launchInst = document.getElementById('launch-instructions');\n                while (!this.runYet) {\n                    launchInst.innerHTML = '&nbsp;';\n                    yield (0,_utils__WEBPACK_IMPORTED_MODULE_1__.timeout)(500);\n                    launchInst.innerHTML = `Press <b>[spacebar]</b> to play.`;\n                    yield (0,_utils__WEBPACK_IMPORTED_MODULE_1__.timeout)(1500);\n                }\n            }\n        });\n    }\n    // -----------------------------------------------------------\n    // PRIVATE\n    // -----------------------------------------------------------\n    findDiv(selectors) {\n        return this.parentEl.querySelector(selectors);\n    }\n    onRunClick() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.runYet) {\n                const btn = document.getElementById('btn-go');\n                if (btn) {\n                    btn.style.display = 'none';\n                }\n                document.body.classList.add('in-game');\n                this.runYet = true;\n                yield this.game.run();\n                // game is over\n                window.location.reload();\n            }\n        });\n    }\n    // -----------------------------------------------------------\n    isMobile() {\n        if (/iPad|Android|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    // -----------------------------------------------------------\n    introDiv() {\n        const mobileMessage = this.isMobile()\n            ? `\n      <div style=\"text-align:center;font-size:2em;margin-top:40px;\">\n         ⚠️ <b>T.C.F.T.G</b> will play on an <b>iPad</b>, but only with an\n         external keyboard. It will not play on phones.\n        </p>\n      </div>\n    `\n            : '';\n        return `    <div class=\"game-intro-wrapper\">\n    <div class=\"intro-note\" style=\"max-width:100%;\">\n      <div style=\"text-align:center\">\n        <img src=\"/images/site/cover.png\" width=\"100%\">\n        <div id=\"load-stats\" style=\"text-align:center;font-size:0.9em;height:14px;\"></div>\n        ${mobileMessage}        \n        <div id=\"launch-instructions\"  style=\"text-align:center;font-size:1.1em;height:20px;margin-top:20px;\"></div>\n      </div>\n      <h4 style=\"margin-top:50px;\">Controls & notes</h4>\n      <p>\n      🎮: T.C.F.T.G. works with 1 or 2 gamepads, and/or keyboard: \n      <br><br>\n        Player 1 ⌨️: <b>a w d</b> to move\n      <br>\n        Player 2 ⌨️: <b>i j l</b> or <b>arrow keys</b>\n      </p>\n      <h4>Latest changes</h4>\n      <p>\n      Fixed control of menu when paused by controller\n      </p>\n      <h4>About</h4>\n      <p>\n      This game is a free, open-source hobby project by <b>Chris Coyne</b> (<a href=\"https://chriscoyne.com\">chriscoyne.com</a>) with help from friends. Contributions accepted. Source code at\n      <a href=\"https://github.com/malgorithms/they-came-from-the-ground\">https://github.com/malgorithms/they-came-from-the-ground</a>. The GitHub readme shows how to run your own\n      copy of the game. It's a joy to change the game physics and rules.\n      </p>\n      </div>\n    </div>`;\n    }\n    generateLayout() {\n        this.parentEl.innerHTML = `\n    <div class=\"world-container\">\n        <div id=\"game-canvas-wrapper\">\n        ${this.introDiv()}\n        </div>\n    </div>`;\n        const loaded = Date.now();\n        // in Chrome, we need to trigger anything audio related by user action, or it won't play.\n        window.onkeydown = (e) => {\n            if (Date.now() - loaded > 100 && e.key === ' ') {\n                this.onRunClick();\n            }\n        };\n        const btn = document.getElementById('btn-go');\n        if (btn)\n            btn.onclick = () => this.onRunClick();\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/page-ui.ts?");

/***/ }),

/***/ "./src/player.ts":
/*!***********************!*\
  !*** ./src/player.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Player\": () => (/* binding */ Player),\n/* harmony export */   \"PlayerSpecies\": () => (/* binding */ PlayerSpecies)\n/* harmony export */ });\n/* harmony import */ var _circular_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./circular-object */ \"./src/circular-object.ts\");\n/* harmony import */ var _tweakables__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tweakables */ \"./src/tweakables.ts\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\n\n\n\nvar PlayerSpecies;\n(function (PlayerSpecies) {\n    PlayerSpecies[\"Ai\"] = \"ai\";\n    PlayerSpecies[\"Human\"] = \"human\";\n    PlayerSpecies[\"Off\"] = \"off\";\n})(PlayerSpecies || (PlayerSpecies = {}));\nclass Player {\n    constructor(o) {\n        this.physics = new _circular_object__WEBPACK_IMPORTED_MODULE_0__.CircularObject(_utils__WEBPACK_IMPORTED_MODULE_2__.vec.zero(), _utils__WEBPACK_IMPORTED_MODULE_2__.vec.zero(), o.diameter, o.mass, 0, 0, o.gravityMultiplier);\n        this.maxVel = o.maxVel;\n        this.targetXVel = o.targetXVel;\n        this.xSpringConstant = o.xSpringConstant;\n    }\n    deepCopy() {\n        const sp = new Player({\n            maxVel: _utils__WEBPACK_IMPORTED_MODULE_2__.vec.copy(this.maxVel),\n            diameter: this.physics.diameter,\n            mass: this.physics.mass,\n            xSpringConstant: this.xSpringConstant,\n            gravityMultiplier: this.physics.gravityMultiplier,\n            targetXVel: this.targetXVel,\n        });\n        sp.physics.center = _utils__WEBPACK_IMPORTED_MODULE_2__.vec.copy(this.physics.center);\n        sp.physics.vel = _utils__WEBPACK_IMPORTED_MODULE_2__.vec.copy(this.physics.vel);\n        sp.physics.orientation = this.physics.orientation;\n        sp.physics.angularVel = this.physics.angularVel;\n        return sp;\n    }\n    jump() {\n        this.physics.vel.y = this.maxVel.y;\n    }\n    grow(dt, vel) {\n        const oldDiameter = this.physics.diameter;\n        this.physics.diameter += vel * dt;\n        if (this.physics.diameter < _tweakables__WEBPACK_IMPORTED_MODULE_1__[\"default\"].player.minDiameter)\n            this.physics.diameter = _tweakables__WEBPACK_IMPORTED_MODULE_1__[\"default\"].player.minDiameter;\n        if (this.physics.diameter > _tweakables__WEBPACK_IMPORTED_MODULE_1__[\"default\"].player.maxDiameter)\n            this.physics.diameter = _tweakables__WEBPACK_IMPORTED_MODULE_1__[\"default\"].player.maxDiameter;\n        const ratio = oldDiameter / this.physics.diameter;\n        this.maxVel.x *= Math.sqrt(ratio);\n        this.maxVel.y *= Math.sqrt(Math.sqrt(ratio));\n        this.physics.mass *= (1 / ratio) * (1 / ratio);\n    }\n    moveRight() {\n        this.targetXVel = this.maxVel.x;\n    }\n    moveLeft() {\n        this.targetXVel = -this.maxVel.x;\n    }\n    moveRationally(fractionOfMaxVelocity) {\n        this.targetXVel = this.maxVel.x * fractionOfMaxVelocity;\n    }\n    stepPosition(dt) {\n        this.physics.center = _utils__WEBPACK_IMPORTED_MODULE_2__.vec.add(this.physics.center, _utils__WEBPACK_IMPORTED_MODULE_2__.vec.scale(this.physics.vel, dt));\n    }\n    stepVelocity(dt, gravity) {\n        const idealVx = this.targetXVel * this.maxVel.x;\n        const difference = idealVx - this.physics.vel.x;\n        this.physics.vel = _utils__WEBPACK_IMPORTED_MODULE_2__.vec.add(this.physics.vel, { x: difference * dt * this.xSpringConstant, y: 0 });\n        // gravity\n        this.physics.vel = _utils__WEBPACK_IMPORTED_MODULE_2__.vec.add(this.physics.vel, _utils__WEBPACK_IMPORTED_MODULE_2__.vec.scale(gravity, dt * this.physics.gravityMultiplier));\n    }\n    isOnHeight(height) {\n        return this.physics.center.y <= height + _tweakables__WEBPACK_IMPORTED_MODULE_1__[\"default\"].proximityTolerance;\n    }\n    isOnPlayer(opponent) {\n        // Jump off opponent! Are you serious?! Yes.\n        const diff = _utils__WEBPACK_IMPORTED_MODULE_2__.vec.sub(this.physics.center, opponent.physics.center);\n        const distance = _utils__WEBPACK_IMPORTED_MODULE_2__.vec.len(diff);\n        if (distance < this.physics.diameter / 2 + opponent.physics.diameter / 2 + _tweakables__WEBPACK_IMPORTED_MODULE_1__[\"default\"].proximityTolerance) {\n            // Only if above opponent\n            if (this.physics.center.y > opponent.physics.center.y) {\n                return true;\n            }\n        }\n        return false;\n    }\n    isOnRectangle(obstacle) {\n        // top-left corner\n        const netTopLeftCorner = { x: obstacle.center.x - obstacle.width / 2, y: obstacle.center.y + obstacle.height / 2 };\n        const distToNetTopLeft = _utils__WEBPACK_IMPORTED_MODULE_2__.vec.len(_utils__WEBPACK_IMPORTED_MODULE_2__.vec.sub(netTopLeftCorner, this.physics.center));\n        if (distToNetTopLeft <= this.physics.diameter / 2 + _tweakables__WEBPACK_IMPORTED_MODULE_1__[\"default\"].proximityTolerance) {\n            return true;\n        }\n        // top-right corner\n        const netTopRightCorner = { x: obstacle.center.x + obstacle.width / 2, y: obstacle.center.y + obstacle.height / 2 };\n        const distToNetTopRight = _utils__WEBPACK_IMPORTED_MODULE_2__.vec.len(_utils__WEBPACK_IMPORTED_MODULE_2__.vec.sub(netTopRightCorner, this.physics.center));\n        if (distToNetTopRight <= this.physics.diameter / 2 + _tweakables__WEBPACK_IMPORTED_MODULE_1__[\"default\"].proximityTolerance) {\n            return true;\n        }\n        // top of it\n        if (this.physics.center.x > obstacle.center.x - obstacle.width / 2 && this.physics.center.x < obstacle.center.x + obstacle.width / 2) {\n            const jumpHeight = obstacle.center.y + obstacle.height / 2 + this.physics.diameter / 2;\n            if (this.isOnHeight(jumpHeight)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    getMaxJumpHeight(gameGravityY) {\n        return (this.maxVel.y * this.maxVel.y) / (2 * Math.abs(gameGravityY * this.physics.gravityMultiplier));\n    }\n    getTimeToJumpToHeight(gameGravityY, height) {\n        // y = y0 + v0t + 0.5at^2\n        // y = 0 + vt + 0.5gt^2\n        // 0.5gt^2 + vt - y = 0\n        // (-v +- sqrt(v*v+2yg) ) / (g)\n        const g = gameGravityY * this.physics.gravityMultiplier;\n        const v = this.maxVel.y;\n        if (v * v + 2 * height * g < 0)\n            return Infinity;\n        else {\n            const answer1 = (-v + Math.sqrt(v * v + 2 * height * g)) / g;\n            const answer2 = (-v - Math.sqrt(v * v + 2 * height * g)) / g;\n            if (answer1 > 0 && answer2 > 0 && answer1 < answer2)\n                return answer1;\n            else if (answer1 > 0 && answer2 > 0 && answer2 < answer1)\n                return answer2;\n            else if (answer2 > 0)\n                return answer2;\n            else if (answer1 > 0)\n                return answer1;\n            else\n                return Infinity;\n        }\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/player.ts?");

/***/ }),

/***/ "./src/rectangular-obstacle.ts":
/*!*************************************!*\
  !*** ./src/rectangular-obstacle.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RectangularObstacle\": () => (/* binding */ RectangularObstacle)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\n\nclass RectangularObstacle {\n    constructor(center, width, height) {\n        this.center = _utils__WEBPACK_IMPORTED_MODULE_0__.vec.copy(center);\n        this.width = width;\n        this.height = height;\n    }\n    handleBallCollision(ball, elasticity) {\n        let didCollide = false;\n        const ballRad = ball.diameter / 2;\n        const cx = this.center.x;\n        const cy = this.center.y;\n        const bx = ball.center.x;\n        const by = ball.center.y;\n        const cLt = cx - this.width / 2;\n        const cRt = cx + this.width / 2;\n        const cUp = cy + this.height / 2;\n        const cDw = cy - this.height / 2;\n        if (bx + ballRad < cLt)\n            return false;\n        if (bx - ballRad > cRt)\n            return false;\n        if (by - ballRad > cUp)\n            return false;\n        if (by + ballRad < cDw)\n            return false;\n        didCollide || (didCollide = ball.handleHittingVerticalSegment({ x: cLt, y: cDw }, { x: cLt, y: cUp }, elasticity));\n        didCollide || (didCollide = ball.handleHittingHorizontalSegment({ x: cLt, y: cUp }, { x: cRt, y: cUp }, elasticity));\n        didCollide || (didCollide = ball.handleHittingVerticalSegment({ x: cRt, y: cDw }, { x: cRt, y: cUp }, elasticity));\n        didCollide || (didCollide = ball.handleHittingHorizontalSegment({ x: cLt, y: cDw }, { x: cRt, y: cDw }, elasticity));\n        didCollide || (didCollide = ball.handleHittingPoint({ x: cLt, y: cDw }, elasticity));\n        didCollide || (didCollide = ball.handleHittingPoint({ x: cLt, y: cUp }, elasticity));\n        didCollide || (didCollide = ball.handleHittingPoint({ x: cRt, y: cUp }, elasticity));\n        didCollide || (didCollide = ball.handleHittingPoint({ x: cRt, y: cDw }, elasticity));\n        return didCollide;\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/rectangular-obstacle.ts?");

/***/ }),

/***/ "./src/score-card.ts":
/*!***************************!*\
  !*** ./src/score-card.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ScoreCard\": () => (/* binding */ ScoreCard)\n/* harmony export */ });\nclass ScoreCard {\n    constructor() {\n        this.sizeMultiplier = 1;\n        this.sizeVelocity = 0;\n        this.springConstant = 24.0;\n        this.dampeningConstant = 1.5;\n        this.bounceVelocity = 2.5;\n        this.minSizeMultiplier = 0.25;\n        this.maxSizeMultiplier = 3.0;\n    }\n    update(dt) {\n        const force = (1.0 - this.sizeMultiplier) * this.springConstant - this.sizeVelocity * this.dampeningConstant;\n        this.sizeVelocity += force * dt;\n        this.sizeMultiplier += this.sizeVelocity * dt;\n        if (this.sizeMultiplier < this.minSizeMultiplier)\n            this.sizeMultiplier = this.minSizeMultiplier;\n        else if (this.sizeMultiplier > this.maxSizeMultiplier)\n            this.sizeMultiplier = this.maxSizeMultiplier;\n    }\n    bounce() {\n        this.sizeVelocity = this.bounceVelocity;\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/score-card.ts?");

/***/ }),

/***/ "./src/sound-effect.ts":
/*!*****************************!*\
  !*** ./src/sound-effect.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SoundEffect\": () => (/* binding */ SoundEffect)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\nclass SoundEffect {\n    constructor(audioBuffer, audioContext) {\n        this.audioBuffer = audioBuffer;\n        this.audioContext = audioContext;\n        this.playingSources = [];\n    }\n    get isPlaying() {\n        return this.playingSources.length > 0;\n    }\n    play(volume, pitch, pan, loop) {\n        const source = this.audioContext.createBufferSource();\n        const currTime = this.audioContext.currentTime;\n        source.buffer = this.audioBuffer;\n        // connect buffer -> gain node -> panner node -> pitch node -> destination\n        const gainNode = this.audioContext.createGain();\n        const pannerNode = this.audioContext.createStereoPanner();\n        if (volume < 0 || volume > 1)\n            throw new Error(`bad volume ${volume}`);\n        if (pan < -1 || pan > 1)\n            throw new Error(`bad pan ${pan}`);\n        if (pitch < -1 || pitch > 1)\n            throw new Error(`bad pitch ${pitch}`);\n        gainNode.gain.linearRampToValueAtTime(volume, currTime);\n        pannerNode.pan.setValueAtTime(pan, 0);\n        // attempt to change pitch. pitch values comes in -1...1\n        let rate = source.playbackRate.value;\n        rate = rate * 1 + pitch / 2;\n        source.playbackRate.setValueAtTime(rate, 0);\n        // connections\n        source.connect(gainNode);\n        gainNode.connect(pannerNode);\n        pannerNode.connect(this.audioContext.destination);\n        source.loop = loop;\n        this.playingSources.push(source);\n        source.start(0, 0);\n        source.onended = () => {\n            this.playingSources.splice(this.playingSources.indexOf(source), 1);\n        };\n        return {\n            source: source,\n            stop: () => this.stopSource(source),\n            gainNode: gainNode,\n            effect: this,\n            fadeOut: (seconds) => this.fadeOutSource(seconds, gainNode, source),\n        };\n    }\n    stopIfPlaying() {\n        for (const s of this.playingSources) {\n            s.stop();\n        }\n        this.playingSources = [];\n    }\n    fadeOutSource(seconds, gainNode, source) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const currTime = this.audioContext.currentTime;\n            gainNode.gain.linearRampToValueAtTime(0, currTime + seconds);\n            yield (0,_utils__WEBPACK_IMPORTED_MODULE_0__.timeout)(seconds);\n            source.stop();\n        });\n    }\n    stopSource(source) {\n        source.stop();\n        this.playingSources = this.playingSources.filter((s) => s !== source);\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/sound-effect.ts?");

/***/ }),

/***/ "./src/sound-manager.ts":
/*!******************************!*\
  !*** ./src/sound-manager.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SoundManager\": () => (/* binding */ SoundManager)\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./src/types.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\nconst soundSources = {\n    themeSong: 'sounds/ThemeSong.mp3',\n    beep: 'sounds/Beep1.mp3',\n    slam: 'sounds/Slam01.mp3',\n    rejected: 'sounds/Rejected.mp3',\n    pointScored: 'sounds/PointScored.mp3',\n    gamePlayMusic: 'sounds/GamePlay02.mp3',\n    p1Growth: 'sounds/SizeChange2.mp3',\n    p2Growth: 'sounds/SizeChange1.mp3',\n    p1Shrinkage: 'sounds/SizeChange2.mp3',\n    p2Shrinkage: 'sounds/SizeChange1.mp3',\n    thud: 'sounds/Hit1.mp3',\n    ding: 'sounds/Hit1.mp3',\n    gamePoint: 'sounds/GamePoint.mp3',\n};\nclass SoundManager {\n    constructor(content) {\n        this.content = content;\n        this.sounds = new Map();\n        this.instances = new Map();\n    }\n    loadSound(path, name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const eff = yield this.content.loadSoundEffect(path);\n            this.sounds.set(name, eff);\n        });\n    }\n    loadContent() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const promises = [];\n            Object.entries(soundSources).forEach(([name, source]) => promises.push(this.loadSound(source, name)));\n            yield Promise.all(promises);\n        });\n    }\n    getSound(name) {\n        const effect = this.sounds.get(name);\n        if (!effect)\n            throw new Error(`no sound was loaded with name ${name}`);\n        return effect;\n    }\n    play(name, volume, pitch, pan, loop) {\n        const soundEffect = this.getSound(name);\n        loop !== null && loop !== void 0 ? loop : (loop = false);\n        const inst = soundEffect.play(volume, pitch, pan, loop);\n        this.instances.set(soundEffect, inst);\n    }\n    playIfNotPlaying(name, volume, pitch, pan, loop) {\n        const soundEffect = this.getSound(name);\n        loop !== null && loop !== void 0 ? loop : (loop = false);\n        if (soundEffect.isPlaying) {\n            // Nope\n        }\n        else {\n            this.play(name, volume, pitch, pan, loop);\n        }\n    }\n    stopIfPlaying(name) {\n        const soundEffect = this.getSound(name);\n        soundEffect.stopIfPlaying();\n        if (this.instances.has(soundEffect))\n            this.instances.delete(soundEffect);\n    }\n    stopThemeMusic() {\n        this.stopIfPlaying('themeSong');\n    }\n    stopPlayMusic() {\n        this.stopIfPlaying('gamePlayMusic');\n    }\n    playGrowthNoise(playerSide, vel) {\n        const isLeft = playerSide === _types__WEBPACK_IMPORTED_MODULE_0__.PlayerSide.Left;\n        if (vel < 0.0 && isLeft)\n            this.playIfNotPlaying('p1Shrinkage', 0.2, -vel, 0.0, true);\n        else if (vel > 0.0 && isLeft)\n            this.playIfNotPlaying('p1Growth', 0.2, -vel, 0.0, true);\n        else if (vel < 0.0 && !isLeft)\n            this.playIfNotPlaying('p2Shrinkage', 0.2, -vel, 0.0, true);\n        else if (vel > 0.0 && !isLeft)\n            this.playIfNotPlaying('p2Growth', 0.2, -vel, 0.0, true);\n    }\n    fadeOutSound(instance, dt, fadeOutSeconds) {\n        instance.fadeOut(fadeOutSeconds);\n    }\n    fadeGrowthNoise(playerSide, dt) {\n        if (playerSide === _types__WEBPACK_IMPORTED_MODULE_0__.PlayerSide.Left) {\n            const sInstance = this.instances.get(this.getSound('p1Shrinkage'));\n            const gInstance = this.instances.get(this.getSound('p1Growth'));\n            if (sInstance === null || sInstance === void 0 ? void 0 : sInstance.effect.isPlaying)\n                this.fadeOutSound(sInstance, dt, 1.0);\n            if (gInstance === null || gInstance === void 0 ? void 0 : gInstance.effect.isPlaying)\n                this.fadeOutSound(gInstance, dt, 1.0);\n        }\n        else {\n            const sInstance = this.instances.get(this.getSound('p2Shrinkage'));\n            const gInstance = this.instances.get(this.getSound('p2Growth'));\n            if (sInstance === null || sInstance === void 0 ? void 0 : sInstance.effect.isPlaying)\n                this.fadeOutSound(sInstance, dt, 1.0);\n            if (gInstance === null || gInstance === void 0 ? void 0 : gInstance.effect.isPlaying)\n                this.fadeOutSound(gInstance, dt, 1.0);\n        }\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/sound-manager.ts?");

/***/ }),

/***/ "./src/sprite-batch.ts":
/*!*****************************!*\
  !*** ./src/sprite-batch.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SpriteBatch\": () => (/* binding */ SpriteBatch)\n/* harmony export */ });\n/* harmony import */ var _tweakables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tweakables */ \"./src/tweakables.ts\");\n\nclass SpriteBatch {\n    constructor(canvasManager) {\n        this.canvasManager = canvasManager;\n    }\n    get ctx() {\n        return this.canvasManager.ctx;\n    }\n    /**\n     * draws a texture on the canvasManager, scaled appropriately. So none of the params\n     * here are dealing with pixels, but actual game units\n     */\n    drawTextureCentered(t, center, dim, rot, alpha) {\n        if (alpha <= 0)\n            return;\n        this.ctx.save();\n        // we need to rotate about center, so let's translate to center, rotate, translate back\n        const w = dim.w;\n        const h = dim.h;\n        const rotCenterX = w / 2;\n        const rotCenterY = h / 2;\n        this.ctx.translate(center.x, center.y);\n        this.ctx.transform(1, 0, 0, -1, 0, 0); // flip y-axis\n        if (rot)\n            this.ctx.rotate(rot);\n        this.ctx.translate(-rotCenterX, -rotCenterY);\n        this.ctx.globalAlpha = alpha;\n        this.ctx.drawImage(t.img, 0, 0, w, h);\n        this.ctx.restore();\n    }\n    drawStringCentered(s, font, size, center, color, rot) {\n        if (color.a === 0)\n            return;\n        this.ctx.save();\n        const pxCenter = this.canvasManager.canvasToPixelPos(center);\n        this.ctx.font = this.fontDescriptor(font, size);\n        const boxTm = this.ctx.measureText(s);\n        const boxWidth = boxTm.width;\n        const boxHeight = boxTm.actualBoundingBoxAscent + boxTm.actualBoundingBoxDescent;\n        this.ctx.resetTransform();\n        const rotCenterX2 = boxWidth / 2;\n        const rotCenterY2 = -boxHeight / 2;\n        this.ctx.translate(pxCenter.x, pxCenter.y);\n        this.ctx.rotate(rot !== null && rot !== void 0 ? rot : 0);\n        this.ctx.translate(-rotCenterX2, -rotCenterY2);\n        this.ctx.fillStyle = color.toHtmlRgb();\n        this.ctx.fillText(s, 0, 0);\n        this.ctx.restore();\n    }\n    drawStringUncentered(s, font, size, pos, color, rot) {\n        if (color.a === 0)\n            return;\n        this.ctx.save();\n        const pxPos = this.canvasManager.canvasToPixelPos(pos);\n        this.ctx.font = this.fontDescriptor(font, size);\n        this.ctx.resetTransform();\n        this.ctx.translate(pxPos.x, pxPos.y);\n        this.ctx.rotate(rot !== null && rot !== void 0 ? rot : 0);\n        this.ctx.fillStyle = color.toHtmlRgb();\n        this.ctx.fillText(s, 0, 0);\n        this.ctx.restore();\n    }\n    drawTextureInRect(t, rect, alpha) {\n        const w = rect.x2 - rect.x1;\n        const h = rect.y2 - rect.y1;\n        const center = { x: (rect.x1 + rect.x2) / 2, y: (rect.y1 + rect.y2) / 2 };\n        this.drawTextureCentered(t, center, { w, h }, 0, alpha);\n    }\n    /**\n     * returns width and height object for the given texture,\n     * given a desired width passed in. basically just scales to aspectRatio.\n     * @param width\n     * @param texture2d\n     * @returns\n     */\n    autoDim(width, texture2d) {\n        return {\n            w: width,\n            h: (width * texture2d.height) / texture2d.width,\n        };\n    }\n    /**\n     * returns something like \"bold 12px 'nunito sans', sans-serif\"\n     * @param font - font definition\n     * @param size - the size in game coordinates; gets converted to pixels\n     * @returns string\n     */\n    fontDescriptor(font, size) {\n        const pixelWidth = this.canvasManager.pixelWidth(1);\n        const pxSize = size / pixelWidth;\n        const res = `${font.weight} ${pxSize.toFixed(4)}px \"${font.family}\", ${_tweakables__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fontFamilyFallback}`;\n        //console.log(`Got font descriptor \"${res}\"`)\n        return res;\n    }\n}\n\n\n\n//# sourceURL=webpack:///./src/sprite-batch.ts?");

/***/ }),

/***/ "./src/tweakables.ts":
/*!***************************!*\
  !*** ./src/tweakables.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n//\n// TODO: extract all the garbage I hard-coded in game.ts into here\n//\nconst twoPlayerControls = {\n    p0: {\n        left: ['KeyA'],\n        right: ['KeyD'],\n        jump: ['KeyW'],\n        shrink: ['KeyQ'],\n        grow: ['KeyE'],\n    },\n    p1: {\n        left: ['KeyJ', 'ArrowLeft'],\n        right: ['KeyL', 'ArrowRight'],\n        jump: ['KeyI', 'ArrowUp'],\n        shrink: ['KeyU', 'Period'],\n        grow: ['KeyO', 'Slash'],\n    },\n};\n// allow any of the above for one player games\nconst p0Set = {\n    left: twoPlayerControls.p0.left.concat(twoPlayerControls.p1.left),\n    right: twoPlayerControls.p0.right.concat(twoPlayerControls.p1.right),\n    jump: twoPlayerControls.p0.jump.concat(twoPlayerControls.p1.jump),\n    shrink: twoPlayerControls.p0.shrink.concat(twoPlayerControls.p1.shrink),\n    grow: twoPlayerControls.p0.grow.concat(twoPlayerControls.p1.grow),\n};\nconst onePlayerControls = {\n    p0: p0Set,\n    p1: p0Set,\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n    twoPlayerControls,\n    onePlayerControls,\n    menu: {\n        bpm: 87,\n        lineSpacing: 1.05,\n    },\n    fpsSampleCount: 100,\n    ballPlayerLaunchTime: 0.5,\n    winningScore: 5,\n    winByTwo: true,\n    gameGravity: { x: 0, y: -1.9 },\n    timeAfterPointToFreeze: 0.5,\n    timeAfterPointToReturnHome: 1.5,\n    predictFutureEvery: 0.3,\n    physicsDt: 0.002,\n    predictionLookahead: 1.75,\n    predictionPhysicsDt: 0.004,\n    predictionStorageDt: 0.02,\n    thumbstickCenterTolerance: 0.05,\n    triggerTolerance: 0.05,\n    triggerGrowthMult: 0.4,\n    keyboardGrowthRate: 0.1,\n    fontFamilyFallback: \"'Courier New', Arial\",\n    net: {\n        center: { x: 0.5, y: 0.025 },\n        width: 0.08,\n        height: 0.055,\n    },\n    leftWall: {\n        center: { x: -0.129, y: 0.5 },\n        width: 0.2579,\n        height: 1.0,\n    },\n    rightWall: {\n        center: { x: 1.129, y: 0.5 },\n        width: 0.2579,\n        height: 1.0,\n    },\n    floorFront: {\n        yMax: 0, // draws below this line\n    },\n    floorBack: {\n        yMax: 0.0365,\n        yMin: -0.07,\n    },\n    ball: {\n        defaultSettings: {\n            mass: 0.1,\n            diameter: 0.08,\n            maxSpeed: 1.4,\n        },\n    },\n    cloud: {\n        num: 5,\n        minVel: { x: 0.01, y: -0.01 },\n        maxVel: { x: 0.07, y: 0.01 },\n    },\n    atmosphere: {\n        timeToTurnSunny: 2,\n        timeToTurnDark: 3,\n    },\n    moon: {\n        nightHeightFrac: 0.75,\n        widthFrac: 0.3,\n    },\n    proximityTolerance: 0.001,\n    player: {\n        growSpeed: 0.1,\n        minDiameter: 0.09,\n        maxDiameter: 0.175,\n        defaultSettings: {\n            maxVel: { x: 0.8, y: 1.2 },\n            diameter: 0.15,\n            mass: 3,\n            xSpringConstant: 30,\n            gravityMultiplier: 1.9,\n            targetXVel: 0,\n        },\n    },\n});\n\n\n//# sourceURL=webpack:///./src/tweakables.ts?");

/***/ }),

/***/ "./src/types.ts":
/*!**********************!*\
  !*** ./src/types.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GameState\": () => (/* binding */ GameState),\n/* harmony export */   \"PlayerSide\": () => (/* binding */ PlayerSide)\n/* harmony export */ });\nvar PlayerSide;\n(function (PlayerSide) {\n    PlayerSide[\"Left\"] = \"left\";\n    PlayerSide[\"Right\"] = \"right\";\n})(PlayerSide || (PlayerSide = {}));\nvar GameState;\n(function (GameState) {\n    GameState[GameState[\"PreStart\"] = 0] = \"PreStart\";\n    GameState[GameState[\"Intro1\"] = 1] = \"Intro1\";\n    GameState[GameState[\"Intro2\"] = 2] = \"Intro2\";\n    GameState[GameState[\"Intro3\"] = 3] = \"Intro3\";\n    GameState[GameState[\"MainMenu\"] = 4] = \"MainMenu\";\n    GameState[GameState[\"PointForPlayer0\"] = 5] = \"PointForPlayer0\";\n    GameState[GameState[\"PointForPlayer1\"] = 6] = \"PointForPlayer1\";\n    GameState[GameState[\"VictoryForPlayer0\"] = 7] = \"VictoryForPlayer0\";\n    GameState[GameState[\"VictoryForPlayer1\"] = 8] = \"VictoryForPlayer1\";\n    GameState[GameState[\"PreAction\"] = 9] = \"PreAction\";\n    GameState[GameState[\"Action\"] = 10] = \"Action\";\n    GameState[GameState[\"Paused\"] = 11] = \"Paused\";\n    GameState[GameState[\"AutoPaused\"] = 12] = \"AutoPaused\";\n    GameState[GameState[\"Instructions\"] = 13] = \"Instructions\";\n    GameState[GameState[\"PreExitMessage\"] = 14] = \"PreExitMessage\";\n    GameState[GameState[\"PreExitCredits\"] = 15] = \"PreExitCredits\";\n    GameState[GameState[\"Exit\"] = 16] = \"Exit\";\n})(GameState || (GameState = {}));\n\n\n\n//# sourceURL=webpack:///./src/types.ts?");

/***/ }),

/***/ "./src/utils.ts":
/*!**********************!*\
  !*** ./src/utils.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"aspectRatio\": () => (/* binding */ aspectRatio),\n/* harmony export */   \"timeout\": () => (/* binding */ timeout),\n/* harmony export */   \"vec\": () => (/* binding */ vec)\n/* harmony export */ });\nfunction timeout(ms) {\n    return new Promise((resolve) => {\n        setTimeout(() => {\n            resolve();\n        }, ms);\n    });\n}\nconst vec = {\n    copy: (v) => ({ x: v.x, y: v.y }),\n    sub: (v1, v2) => ({ x: v1.x - v2.x, y: v1.y - v2.y }),\n    add: (v1, v2) => ({ x: v1.x + v2.x, y: v1.y + v2.y }),\n    lenSq: (v) => v.x * v.x + v.y * v.y,\n    len: (v) => Math.sqrt(vec.lenSq(v)),\n    scale: (v, k) => ({ x: v.x * k, y: v.y * k }),\n    normalized: (v) => {\n        const len = vec.len(v);\n        return { x: v.x / len, y: v.y / len };\n    },\n    dotProduct: (v1, v2) => v1.x * v2.x + v1.y * v2.y,\n    zero: () => ({ x: 0, y: 0 }),\n    transform: (p, matrix) => {\n        const x = p.x * matrix.a + p.y * matrix.c + matrix.e;\n        const y = p.x * matrix.b + p.y * matrix.d + matrix.f;\n        return { x, y };\n    },\n    avg: (v1, v2) => {\n        return {\n            x: (v1.x + v2.x) / 2,\n            y: (v1.y + v2.y) / 2,\n        };\n    },\n};\nconst aspectRatio = (t) => t.width / t.height;\n\n\n\n//# sourceURL=webpack:///./src/utils.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;